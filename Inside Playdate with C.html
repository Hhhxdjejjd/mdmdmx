<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Copyright © Panic Inc.">
<title>Inside Playdate with C</title>
<link rel="stylesheet" href="./Inside%20Playdate/adoc.css">

<link rel="stylesheet" href="./Inside%20Playdate/colors.css">
<link rel="stylesheet" href="./Inside%20Playdate/themes.css">
<link rel="stylesheet" href="./Inside%20Playdate/fonts.css">
<link rel="stylesheet" href="./Inside%20Playdate/coderay.css">
</head>
<body class="article">
<div id="header">
<h1>Inside Playdate with C</h1>
<div class="details">
<span id="author" class="author">Copyright © Panic Inc.</span><br>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about_the_c_api">1. About the C API</a>
<ul class="sectlevel2">
<li><a href="#_why_use_the_c_api">1.1. Why use the C API?</a>
<ul class="sectlevel3">
<li><a href="#_before_porting_to_c">Before porting to C</a></li>
</ul>
</li>
<li><a href="#_how_to_use_the_c_api">1.2. How to use the C API</a></li>
<li><a href="#_xcode">1.3. Xcode</a></li>
<li><a href="#_xcodemake">1.4. Xcode/Make</a></li>
</ul>
</li>
<li><a href="#_command_line_tools">2. Command line tools</a>
<ul class="sectlevel2">
<li><a href="#_set_playdate_sdk_path_environment_variable">2.1. Set <code>PLAYDATE_SDK_PATH</code> Environment Variable</a></li>
<li><a href="#_clioncmake">2.2. CLion/CMake</a></li>
<li><a href="#_cmake">2.3. CMake</a></li>
<li><a href="#_make">2.4. Make</a></li>
</ul>
</li>
<li><a href="#_building_on_windows_using_visual_studiocmake">3. Building on Windows using Visual Studio/CMake</a>
<ul class="sectlevel2">
<li><a href="#_install_development_tools">3.1. Install Development Tools</a></li>
<li><a href="#_set_playdate_sdk_path_environment_variable_2">3.2. Set <code>PLAYDATE_SDK_PATH</code> Environment Variable</a>
<ul class="sectlevel3">
<li><a href="#_building">Building</a></li>
</ul>
</li>
<li><a href="#_building_for_the_simulator_using_visual_studio">3.3. Building for the Simulator using Visual Studio</a></li>
<li><a href="#_building_for_the_simulator_using_nmake">3.4. Building for the Simulator using NMake</a></li>
<li><a href="#_building_for_the_playdate_using_nmake">3.5. Building for the Playdate using NMake</a>
<ul class="sectlevel3">
<li><a href="#_building_for_release">Building for Release</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_game_initialization">4. Game Initialization</a></li>
<li><a href="#_api_reference">5. API reference</a>
<ul class="sectlevel2">
<li><a href="#_utility_functions">5.1. Utility functions</a>
<ul class="sectlevel3">
<li><a href="#_memory_allocation">Memory allocation</a></li>
<li><a href="#_logging">Logging</a></li>
<li><a href="#_interacting_with_the_system_menu">Interacting with the System Menu</a></li>
<li><a href="#_miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a href="#_audio">5.2. Audio</a>
<ul class="sectlevel3">
<li><a href="#C-sound.channel">Channels</a></li>
<li><a href="#C-sound.source">SoundSource</a></li>
<li><a href="#C-sound.sample">AudioSample</a></li>
<li><a href="#C-sound.fileplayer">FilePlayer</a></li>
<li><a href="#C-sound.sampleplayer">SamplePlayer</a></li>
<li><a href="#C-sound.synth">PDSynth</a></li>
<li><a href="#C-sound.PDSynthInstrument">PDSynthInstrument</a></li>
<li><a href="#C-sound.signal">Signals</a></li>
<li><a href="#C-sound.lfo">LFO</a></li>
<li><a href="#C-sound.envelope">Envelope</a></li>
<li><a href="#C-sound.effect">SoundEffect</a></li>
<li><a href="#C-sound.twoPoleFilter">TwoPoleFilter</a></li>
<li><a href="#C-sound.onePoleFilter">OnePoleFilter</a></li>
<li><a href="#C-sound.bitCrusher">BitCrusher</a></li>
<li><a href="#C-sound.ringModulator">RingModulator</a></li>
<li><a href="#C-sound.overdrive">Overdrive</a></li>
<li><a href="#C-sound.delayLine">DelayLine</a></li>
<li><a href="#C-sound.delayLineTap">DelayLineTap</a></li>
<li><a href="#C-sound.sequence">SoundSequence</a></li>
<li><a href="#C-sound.ControlSignal">ControlSignal</a></li>
<li><a href="#C-sound.SequenceTrack">SequenceTrack</a></li>
</ul>
</li>
<li><a href="#_display">5.3. Display</a></li>
<li><a href="#_filesystem">5.4. Filesystem</a>
<ul class="sectlevel3">
<li><a href="#_files">Files</a></li>
</ul>
</li>
<li><a href="#_graphics">5.5. Graphics</a>
<ul class="sectlevel3">
<li><a href="#_supporting_types">Supporting types</a></li>
<li><a href="#_bitmaps">Bitmaps</a></li>
<li><a href="#_bitmaptables">BitmapTables</a></li>
<li><a href="#_fonts_text">Fonts &amp; Text</a></li>
<li><a href="#_geometry">Geometry</a></li>
<li><a href="#_miscellaneous_2">Miscellaneous</a></li>
</ul>
</li>
<li><a href="#_video">5.6. Video</a></li>
<li><a href="#_input">5.7. Input</a>
<ul class="sectlevel3">
<li><a href="#_accelerometer">Accelerometer</a></li>
<li><a href="#_buttons">Buttons</a></li>
<li><a href="#_crank">Crank</a></li>
</ul>
</li>
<li><a href="#M-autoLock">5.8. Device Auto Lock</a></li>
<li><a href="#M-systemSounds">5.9. System Sounds</a></li>
<li><a href="#_json">5.10. JSON</a>
<ul class="sectlevel3">
<li><a href="#_decoding">Decoding</a></li>
<li><a href="#_encoding">Encoding</a></li>
</ul>
</li>
<li><a href="#_lua">5.11. Lua</a>
<ul class="sectlevel3">
<li><a href="#_adding_functions_or_tables">Adding functions or tables</a></li>
<li><a href="#_getting_values_from_lua">Getting values from Lua</a></li>
<li><a href="#_returning_values_to_lua">Returning values to Lua</a></li>
<li><a href="#_passing_custom_objects_between_c_and_lua">Passing custom objects between C and Lua</a></li>
<li><a href="#_calling_lua_from_c">Calling Lua from C</a></li>
</ul>
</li>
<li><a href="#_sprites">5.12. Sprites</a>
<ul class="sectlevel3">
<li><a href="#_properties">Properties</a></li>
<li><a href="#_display_list">Display List</a></li>
<li><a href="#_collisions">Collisions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#performance-considerations">6. Performance Considerations</a>
<ul class="sectlevel2">
<li><a href="#_floating_point_math_operations">6.1. Floating point Math operations</a></li>
</ul>
</li>
<li><a href="#getting-help">7. Getting Help</a>
<ul class="sectlevel2">
<li><a href="#_where_can_i_download_the_sdk">7.1. Where can I download the SDK?</a></li>
<li><a href="#_where_do_i_go_if_i_have_questions_about_the_sdk">7.2. Where do I go if I have questions about the SDK?</a></li>
<li><a href="#_where_do_i_report_bugs_or_issues_relating_to_the_sdk">7.3. Where do I report bugs or issues relating to the SDK?</a></li>
<li><a href="#_list_of_helpful_libraries_and_code">7.4. List of Helpful Libraries and Code</a></li>
</ul>
</li>
<li><a href="#_legal_information">8. Legal information</a></li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_about_the_c_api">1. About the C API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Playdate&#8217;s C API lets you use native C code in your game, using the same code to build both an OS specific library for the Simulator and a bin file for the Playdate hardware. Most games will use Playdate&#8217;s Lua API (documented in <a href="./Inside%20Playdate.html">Inside Playdate with Lua</a>). We include several example C programs in the SDK found at <code>C_API/Examples</code>. Read on to learn why and how to take advantage of the C API.</p>
</div>
<div class="sect2">
<h3 id="_why_use_the_c_api">1.1. Why use the C API?</h3>
<div class="paragraph">
<p>Performance. Lua is garbage collected. Its garbage collector&#8217;s performance varies wildly from game-to-game and even frame-to-frame within the same game. The collector&#8217;s performance is dependent on the amount of garbage generated per frame and, perhaps counterintuitively, the amount of persistent, non-garbage present in a frame (which it has to crawl to discover new garbage).</p>
</div>
<div class="sect3">
<h4 id="_before_porting_to_c">Before porting to C</h4>
<div class="paragraph">
<p>Depending on how you&#8217;ve used Lua, porting part or all of your existing game from Lua to C can be quite involved. Make sure you&#8217;ve squeezed every last bit of performance out of Lua before refactoring or completely rewriting your game.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>flatten loops as much as possible</p>
</li>
<li>
<p>localize frequently used global tables and functions, especially those used in loops</p>
</li>
<li>
<p>disk access is slow on the hardware, preload any external assets like images, fonts, and sound effects</p>
</li>
<li>
<p>pre-compute and cache the result of expensive computations</p>
</li>
<li>
<p>pre-render and cache the result of expensive drawing routines</p>
</li>
<li>
<p>pre-allocate and reuse tables</p>
</li>
<li>
<p>move table allocations out of loops</p>
</li>
<li>
<p>avoid excessive string concatenation with <code>..</code>, instead build a table of strings and use <code>table.concat()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s worth mentioning that some of these suggestions are directly opposed with minimizing the amount of objects in active memory.</p>
</div>
<div class="paragraph">
<p>Also, be sure to profile on the hardware, the Playdate Simulator is often considerably faster than the hardware.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_use_the_c_api">1.2. How to use the C API</h3>
<div class="paragraph">
<p>There are two primary use cases for the C API:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>extending the Lua runtime by adding native functions your Lua game can use (see <a href="#f-lua.addFunction">playdate->lua->addFunction()</a> and <a href="#f-lua.registerClass">playdate->lua->registerClass()</a>)</p>
</li>
<li>
<p>bypassing the Lua runtime completely by replacing the Lua update callback with your own native function and building your entire game in C (see <a href="#f-system.setUpdateCallback">playdate->system->setUpdateCallback()</a>)</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_xcode">1.3. Xcode</h3>
<div class="paragraph">
<p>To use Xcode to build the example C projects, you will first need to generate the Xcode project file from the CMake file. To do this, you&#8217;ll need CMake installed, we recommend installing it using <a href="https://brew.sh">Brew</a>. Once installed, open the Terminal and navigate into an example project and run the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">mkdir build
cd build
cmake .. -G <span class="string"><span class="delimiter">&quot;</span><span class="content">Xcode</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create an Xcode project in the <code>build</code> directory.  This Xcode project will produce a .pdx that&#8217;s ready to run and debug in the Simulator.  When you want to build for the device, delete the contents of the <code>build</code> folder (or create a second folder), then run these commands which build an ARM binary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">cd build
cmake -DCMAKE_TOOLCHAIN_FILE=&lt;path to SDK&gt;/C_API/buildsupport/arm.cmake ..
make</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_xcodemake">1.4. Xcode/Make</h3>
<div class="paragraph">
<p>Using Xcode for Playdate development requires a few project settings in order to get in-simulator debugging working.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Begin by making sure you have a working Makefile in your project root. The Makefile in the <code>Hello World</code> example project can serve as a starting template.</p>
</li>
<li>
<p>Create a new Xcode Project with a macos Library target and set it up as a plain C library. We recommend you add the word 'Simulator' to the target name</p>
</li>
<li>
<p>Add your source files to the target&#8217;s "compile sources" build phase</p>
</li>
<li>
<p>Add the full path to the SDK/C_API folder to the <em>Header Search Paths</em> build setting</p>
</li>
<li>
<p>Add <code>PLAYDATE_SIMULATOR=1</code> and <code>TARGET_EXTENSION=1</code> to the <em>Preprocessor Macros</em> build setting</p>
</li>
<li>
<p>Add a new script build phase called <code>Compile PDX</code> with the following in the body</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">        cp <span class="string"><span class="delimiter">&quot;</span><span class="content">${TARGET_BUILD_DIR}/${EXECUTABLE_NAME}</span><span class="delimiter">&quot;</span></span> Source/pdex.dylib
        touch Source/pdex.bin
        make pdc</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming you don&#8217;t have any syntax errors in your code your game should now build successfully. Next we need to
hook up the Simulator to run your game in the Xcode debugger.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Edit the Scheme for your library target</p>
</li>
<li>
<p>In the Run configuration set the Executable to the Playdate simulator</p>
</li>
<li>
<p>Switch to the <em>Arguments</em> tab of the Run configuration and add the full path to the compiled .pdx bundle. It&#8217;s recommended that you put double-quotes around the path in case there are spaces in it.</p>
</li>
<li>
<p>Close the scheme and Run your game</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In order to build for the device you&#8217;ll need to do the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new <em>External Build System</em> target with 'Device' in the name to differentiate it</p>
</li>
<li>
<p>Select the <em>Info</em> section of the new target and set the Arguments to <code>device pdc</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Building the new Device target will add the cross-compiled binary to the .pdx bundle to run on the device.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_command_line_tools">2. Command line tools</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_set_playdate_sdk_path_environment_variable">2.1. Set <code>PLAYDATE_SDK_PATH</code> Environment Variable</h3>
<div class="ulist">
<ul>
<li>
<p>On macOS, it is not required, but recommended</p>
</li>
<li>
<p>On Linux, it is required for CMake and Make files</p>
</li>
<li>
<p>On Windows, it is required for CMake (see the Building on Windows section for instructions)</p>
<div class="dlist">
<dl>
<dt class="hdlist1">zsh</dt>
<dd>
<p><code>edit ~/.zprofile</code></p>
</dd>
<dt class="hdlist1">bash</dt>
<dd>
<p><code>edit ~/.bash_profile</code> or <code>edit ~/.bashrc</code></p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add the following line — <code>export PLAYDATE_SDK_PATH=&lt;path to SDK&gt;</code> — replacing the placeholder text with your SDK location.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>pdc</code> compiler will also use this value for the default location of the SDK if it is not specified using the <code>-sdkpath</code> flag.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You may also want to add <code>&lt;path to SDK&gt;/bin</code> to your shell <code>$PATH</code> variable. This allows running <code>pdc</code>, <code>pdutil</code> and the Simulator from any location without a fully qualified path.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_clioncmake">2.2. CLion/CMake</h3>
<div class="paragraph">
<p>CLion uses CMake files for most of it&#8217;s project configuration so project setup is straightforward</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a <code>CMakeLists.txt</code> file to your project. The CMake file in the <code>Hello World</code> example project can serve as a starting template.</p>
</li>
<li>
<p>Open your project folder in CLion. It will detect the names of the simulator and device targets automatically.</p>
</li>
<li>
<p>Open Preferences&#8594;Build&#8594;CMake and add a new build configuration with the following settings</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Name: <code>Device</code></p>
</li>
<li>
<p>Build Type: <code>Debug</code></p>
</li>
<li>
<p>CMake Options: <code>-DCMAKE_TOOLCHAIN_FILE=&lt;path to SDK&gt;/C_API/buildsupport/arm.cmake</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once CLion reloads you&#8217;ll see that when you toggle between your simulator and device target CLion select the appropriate build configuration. Next, you&#8217;ll need to tell CLion how to run the Simulator</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open the <em>Edit Configurations</em> menu</p>
</li>
<li>
<p>Select your simulator target and set the <em>Executable</em> to the Playdate simulator executable. The binary executable is at <code>SDK/bin/Playdate Simulator/Contents/Macos/Playdate Simulator</code></p>
</li>
<li>
<p>Set the <em>Program arguments</em> to the path of the compiled pdx bundle. Use <code>^-F</code> to access a file picker.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_cmake">2.3. CMake</h3>
<div class="paragraph">
<p>To build with CMake using Make run the following commands from the root of the project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">mkdir build
cd build
cmake ..
make</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will produce a PDX that&#8217;s ready to run on the simulator. When you want to build for the device, delete the contents of the <code>build</code> folder (or create a second folder), then run these commands which build an ARM binary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">cd build
cmake -DCMAKE_TOOLCHAIN_FILE=&lt;path to SDK&gt;/C_API/buildsupport/arm.cmake ..
make</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_make">2.4. Make</h3>
<div class="paragraph">
<p>To build Playdate games using the example Makefiles you&#8217;ll need to install <code>arm-none-eabi-newlib</code> packages (naming may vary based on distro) as well as the usual C dev packages. Once these are installed, building is as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c">cd &lt;project folder&gt;
make simulator</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will produce a build folder with a .so file that&#8217;s ready to run on the simulator. Make options are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>simulator</code></dt>
<dd>
<p>builds a .so file for the simulator</p>
</dd>
<dt class="hdlist1"><code>pdc</code></dt>
<dd>
<p>builds a .pdx bundle that will run in the simulator</p>
</dd>
<dt class="hdlist1"><code>device</code></dt>
<dd>
<p>builds a .bin file for the device</p>
</dd>
<dt class="hdlist1">&lt;none&gt;</dt>
<dd>
<p>builds a .pdx bundle suitable for both the simulator and device</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_on_windows_using_visual_studiocmake">3. Building on Windows using Visual Studio/CMake</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These instructions will show you how to build the example C projects included with the Playdate SDK which include CMakeLists. You can use our CMake files as a jumping off point for your own projects. Make is not supported in our example projects on Windows.</p>
</div>
<div class="sect2">
<h3 id="_install_development_tools">3.1. Install Development Tools</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install Visual Studio 2019 or 2022 with C tools</p>
</li>
<li>
<p>Install the GNU Arm Embedded Toolchain compiler <code>gcc-arm-none-eabi</code> from <a href="https://developer.arm.com">developer.arm.com</a>, when prompted add to Windows <code>PATH</code> environment variable</p>
</li>
<li>
<p>Install CMake for Windows from <a href="https://cmake.org">cmake.org</a>, when prompted add to Windows <code>PATH</code> environment variable. You may also use the CMake that comes with Visual Studio.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_set_playdate_sdk_path_environment_variable_2">3.2. Set <code>PLAYDATE_SDK_PATH</code> Environment Variable</h3>
<div class="paragraph">
<p>The CMake build files find the Playdate SDK location by using an environment variable. To set it do the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From the Start Menu type <code>Environment Variables</code> and open the System Properties panel</p>
</li>
<li>
<p>Press the <em>Environment Variables&#8230;&#8203;</em> button</p>
</li>
<li>
<p>Press <em>New&#8230;&#8203;</em> and add <code>PLAYDATE_SDK_PATH</code> and select the location of your Playdate SDK directory</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You may also want to add <code>&lt;path to SDK&gt;/bin</code> to your <code>$PATH</code> variable. This allows running <code>pdc</code>, <code>pdutil</code> and the Simulator from any location without a fully qualified path.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_building">Building</h4>
<div class="paragraph">
<p>The simulator only supports 64 bit binary files. To ensure building 64 bit you&#8217;ll need to use the 64 bit Developer Command Prompt. To open this, select the Start Menu and find the application "x64 Native Tools Command Prompt for VS 2019". The name may vary based on which version of Visual Studio you have. It also can be opened from the Visual Studio Tools menu.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_building_for_the_simulator_using_visual_studio">3.3. Building for the Simulator using Visual Studio</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate into the project directory and create a <code>build</code> folder, this is where CMake will generate its project files</p>
</li>
<li>
<p>Open a Visual Studio Developer Command Prompt from the Start Menu or from within Visual Studio</p>
</li>
<li>
<p>In the developer command prompt window, navigate into <code>build</code> directory and type <code>cmake ..</code></p>
</li>
<li>
<p>Open the Visual Studio project generated in the <code>build</code> directory with the project name</p>
</li>
<li>
<p>In the Solutions Explorer within Visual Studio, select the target with the project name, not a meta target.</p>
</li>
<li>
<p>Right-click and select "Set as Startup Project"</p>
</li>
<li>
<p>Build and Run will create a .pdx file at the root level of the project directory and start a debugging session with the active .pdx by opening the Simulator.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_building_for_the_simulator_using_nmake">3.4. Building for the Simulator using NMake</h3>
<div class="paragraph">
<p>If you&#8217;d like to use VSCode or a different IDE you can also build using NMake.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate into the project directory and create a <code>build</code> folder, this is where cmake will generate its project files</p>
</li>
<li>
<p>Open a Visual Studio Developer Command Prompt from the Start Menu or from within Visual Studio</p>
</li>
<li>
<p>In the developer command prompt window, navigate into build directory and type <code>cmake .. -G "NMake Makefiles"</code></p>
</li>
<li>
<p>Type <code>nmake</code> to build the project. This will create a .pdx file at the root level of the project directory which can be run in the Simulator.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_building_for_the_playdate_using_nmake">3.5. Building for the Playdate using NMake</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Navigate into the project directory and create a <code>build</code> folder, this is where cmake will generate its project files</p>
</li>
<li>
<p>Open a Visual Studio Developer Command Prompt from the Start Menu or from within Visual Studio</p>
</li>
<li>
<p>In the developer command prompt window, navigate into build directory and type <code>cmake .. -G "NMake Makefiles" --toolchain=&lt;path to SDK&gt;/C_API/buildsupport/arm.cmake</code></p>
</li>
<li>
<p>Type <code>nmake</code> to build the project. This will create a .pdx file at the root level of the project directory which can be run on the Playdate.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_building_for_release">Building for Release</h4>
<div class="paragraph">
<p>When you&#8217;re ready to do a release build, regenerate the build targets by passing <code>-DCMAKE_BUILD_TYPE=Release</code> argument to CMake.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This does an optimized build with the current tool chain. To release build for Playdate hardware, you will need to use the ARM tool chain listed above. In Visual Studio this argument is ignored; to do a release build with Visual Studio select Release from the build popup menu.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_game_initialization">4. Game Initialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When building for the device a <code>pdex.bin</code> file is created. The game launcher looks for this file in the compiled .pdx bundle and loads it into memory if it exists. (Because the Playdate OS doesn’t have a dynamic loader, the bin file is compiled for a specific location in memory; therefore, you can only have one bin/dylib per pdx bundle.).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
On Windows, your event handler must be exported, you do this by adding the attribute <code>__declspec(dllexport)</code> to the function.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your code should implement the function:</p>
</div>
<div id="_eventHandler" class="literalblock">
<div class="content">
<pre>int eventHandler(PlaydateAPI* playdate, PDSystemEvent event, uint32_t arg);</pre>
</div>
</div>
<div class="literalblock">
<div class="title">PDSystemEvent</div>
<div class="content">
<pre>typedef enum
{
	kEventInit,
	kEventInitLua,
	kEventLock,
	kEventUnlock,
	kEventPause,
	kEventResume,
	kEventTerminate,
	kEventKeyPressed,
	kEventKeyReleased,
	kEventLowPower
} PDSystemEvent;</pre>
</div>
</div>
<div class="paragraph">
<p>When your <code>eventHandler</code> function is called, the <em>playdate</em> argument will contain a pointer to the PlaydateAPI struct. The PlaydateAPI struct is your game&#8217;s interface back to the Playdate runtime, containing functions for accessing the sound system, display, filesystem, etc.</p>
</div>
<div class="paragraph">
<p>After loading <code>pdex.bin</code> into memory, the system calls your <code>eventHandler()</code> with <em>event</em> set to <code>kEventInit</code>. If your game is implemented entirely in C code, you can supply your own run loop update function by calling <a href="#f-system.setUpdateCallback">playdate->system->setUpdateCallback()</a> here.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t provide an update callback, the system initializes a Lua context and calls <code>eventHandler()</code> again with <em>event</em> equal to <code>kEventInitLua</code>. At this point, you can use <a href="#f-lua.addFunction">playdate->lua->addFunction()</a> and <a href="#f-lua.registerClass">playdate->lua->registerClass()</a> to extend the Lua runtime. Note that this happens before main.lua is loaded and run.</p>
</div>
<div class="paragraph">
<p>When an arbitrary key is pressed or released in the simulator this function is called with <em>event</em> set to <code>kEventKeyPressed</code> or <code>kEventKeyReleased</code> and the keycode of the key in the <em>arg</em> argument.</p>
</div>
<div class="paragraph">
<p>Finally, this function can also handle lifetime events like device lock and unlock, as well as game pause, resume, terminate, and low-power sleep.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_api_reference">5. API reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_utility_functions">5.1. Utility functions</h3>
<div class="sect3">
<h4 id="_memory_allocation">Memory allocation</h4>
<div id="f-system.realloc" class="openblock item function">
<div class="title">void* playdate->system->realloc(void* ptr, size_t size)</div>
<div class="content">
<div class="paragraph">
<p>Allocates heap space if <em>ptr</em> is NULL, else reallocates the given pointer. If <em>size</em> is zero, frees the given pointer.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logging">Logging</h4>
<div id="f-system.error" class="openblock item function">
<div class="title">void playdate->system->error(const char* format, ...)</div>
<div class="content">
<div class="paragraph">
<p>Calls the log function, outputting an error in red to the console, then pauses execution.</p>
</div>
</div>
</div>
<div id="f-system.logToConsole" class="openblock item function xref">
<div class="title">void playdate->system->logToConsole(const char* format, ...)</div>
<div class="content">
<div class="paragraph">
<p>Calls the log function.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-print"><code>print()</code></a> in the Lua API.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interacting_with_the_system_menu">Interacting with the System Menu</h4>
<div class="paragraph">
<p>Your game can add up to three menu items to the system menu. Three types of menu items are supported: normal action menu items, checkmark menu items, and options menu items.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="C">PDMenuItem *menuItem = pd-&gt;system-&gt;addMenuItem(<span class="string"><span class="delimiter">&quot;</span><span class="content">Item 1</span><span class="delimiter">&quot;</span></span>, menuItemCallback, <span class="predefined-constant">NULL</span>);
PDMenuItem *checkMenuItem = pd-&gt;system-&gt;addCheckmarkMenuItem(<span class="string"><span class="delimiter">&quot;</span><span class="content">Item 2</span><span class="delimiter">&quot;</span></span>, <span class="integer">1</span>, menuCheckmarkCallback, <span class="predefined-constant">NULL</span>);
<span class="directive">const</span> <span class="predefined-type">char</span> *options[] = {<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">three</span><span class="delimiter">&quot;</span></span>};
PDMenuItem *optionMenuItem = pd-&gt;system-&gt;addOptionsMenuItem(<span class="string"><span class="delimiter">&quot;</span><span class="content">Item 3</span><span class="delimiter">&quot;</span></span>, options, <span class="integer">3</span>, menuOptionsCallback, <span class="predefined-constant">NULL</span>);</code></pre>
</div>
</div>
<div id="f-system.addMenuItem" class="openblock item function">
<div class="title">PDMenuItem* playdate->system->addMenuItem(const char* title, PDMenuItemCallbackFunction* callback, void* userdata)</div>
<div class="content">
<div class="paragraph">
<p><em>title</em> will be the title displayed by the menu item.</p>
</div>
<div class="paragraph">
<p>Adds a new menu item to the System Menu. When invoked by the user, this menu item will:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Invoke your <em>callback</em> function.</p>
</li>
<li>
<p>Hide the System Menu.</p>
</li>
<li>
<p>Unpause your game and call <a href="#_eventHandler">eventHandler()</a> with the kEventResume <em>event</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your game can then present an options interface to the player, or take other action, in whatever manner you choose.</p>
</div>
</div>
</div>
<div id="f-system.addCheckmarkMenuItem" class="openblock item function">
<div class="title">PDMenuItem* playdate->system->addCheckmarkMenuItem(const char* title, int value, PDMenuItemCallbackFunction* callback, void* userdata)</div>
<div class="content">
<div class="paragraph">
<p>Adds a new menu item that can be checked or unchecked by the player.</p>
</div>
<div class="paragraph">
<p><em>title</em> will be the title displayed by the menu item.</p>
</div>
<div class="paragraph">
<p><em>value</em> should be 0 for unchecked, 1 for checked.</p>
</div>
<div class="paragraph">
<p>If this menu item is interacted with while the system menu is open, <em>callback</em> will be called when the menu is closed.</p>
</div>
</div>
</div>
<div id="f-system.addOptionsMenuItem" class="openblock item function">
<div class="title">PDMenuItem* playdate->system->addOptionsMenuItem(const char* title, const char** options, int optionsCount, PDMenuItemCallbackFunction* callback, void* userdata)</div>
<div class="content">
<div class="paragraph">
<p>Adds a new menu item that allows the player to cycle through a set of options.</p>
</div>
<div class="paragraph">
<p><em>title</em> will be the title displayed by the menu item.</p>
</div>
<div class="paragraph">
<p><em>options</em> should be an array of strings representing the states this menu item can cycle through. Due to limited horizontal space, the option strings and title should be kept short for this type of menu item.</p>
</div>
<div class="paragraph">
<p><em>optionsCount</em> should be the number of items contained in <em>options</em>.</p>
</div>
<div class="paragraph">
<p>If this menu item is interacted with while the system menu is open, <em>callback</em> will be called when the menu is closed.</p>
</div>
</div>
</div>
<div id="f-system.removeMenuItem" class="openblock item function">
<div class="title">void playdate->system->removeMenuItem(PDMenuItem *menuItem)</div>
<div class="content">
<div class="paragraph">
<p>Removes the menu item from the system menu.</p>
</div>
</div>
</div>
<div id="f-system.removeAllMenuItems" class="openblock item function">
<div class="title">void playdate->system->removeAllMenuItems()</div>
<div class="content">
<div class="paragraph">
<p>Removes all custom menu items from the system menu.</p>
</div>
</div>
</div>
<div id="f-system.getMenuItemTitle" class="openblock item function">
<div class="title">const char* playdate->system->getMenuItemTitle(PDMenuItem *menuItem)</div>
<div class="content">

</div>
</div>
<div id="f-system.setMenuItemTitle" class="openblock item function">
<div class="title">void playdate->system->setMenuItemTitle(PDMenuItem *menuItem, const char* title)</div>
<div class="content">
<div class="paragraph">
<p>Gets or sets the display title of the menu item.</p>
</div>
</div>
</div>
<div id="f-system.getMenuItemValue" class="openblock item function">
<div class="title">int playdate->system->getMenuItemValue(PDMenuItem *menuItem)</div>
<div class="content">

</div>
</div>
<div id="f-system.setMenuItemValue" class="openblock item function">
<div class="title">void playdate->system->setMenuItemValue(PDMenuItem *menuItem, int value)</div>
<div class="content">
<div class="paragraph">
<p>Gets or sets the integer value of the menu item.</p>
</div>
<div class="paragraph">
<p>For checkmark menu items, 1 means checked, 0 unchecked. For option menu items, the value indicates the array index of the currently selected option.</p>
</div>
</div>
</div>
<div id="f-system.getMenuItemUserdata" class="openblock item function">
<div class="title">void* playdate->system->getMenuItemUserdata(PDMenuItem *menuItem)</div>
<div class="content">

</div>
</div>
<div id="f-system.setMenuItemUserdata" class="openblock item function">
<div class="title">void playdate->system->setMenuItemUserdata(PDMenuItem *menuItem, void* userdata)</div>
<div class="content">
<div class="paragraph">
<p>Gets or sets the userdata value associated with this menu item.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_miscellaneous">Miscellaneous</h4>
<div id="f-system.getCurrentTimeMilliseconds" class="openblock item function">
<div class="title">unsigned int playdate->system->getCurrentTimeMilliseconds(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of milliseconds since&#8230;&#8203;some arbitrary point in time. This should present a consistent timebase while a game is running, but the counter will be disabled when the device is sleeping.</p>
</div>
</div>
</div>
<div id="f-system.getSecondsSinceEpoch" class="openblock item function">
<div class="title">unsigned int playdate->system->getSecondsSinceEpoch(unsigned int *milliseconds)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of seconds (and sets <em>milliseconds</em> if not NULL) elapsed since midnight (hour 0), January 1, 2000.</p>
</div>
</div>
</div>
<div id="f-system.resetElapsedTime" class="openblock item function">
<div class="title">void playdate->system->resetElapsedTime(void)</div>
<div class="content">
<div class="paragraph">
<p>Resets the high-resolution timer.</p>
</div>
</div>
</div>
<div id="f-system.getElapsedTime" class="openblock item function">
<div class="title">float playdate->system->getElapsedTime(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of seconds since <code>playdate.resetElapsedTime()</code> was called. The value is a floating-point number with microsecond accuracy.</p>
</div>
</div>
</div>
<div id="f-system.getFlipped" class="openblock item function">
<div class="title">int playdate->system->getFlipped()</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the global "flipped" system setting is set, otherwise 0.</p>
</div>
</div>
</div>
<div id="f-system.getReduceFlashing" class="openblock item function">
<div class="title">int playdate->system->getReduceFlashing()</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the global "reduce flashing" system setting is set, otherwise 0.</p>
</div>
</div>
</div>
<div id="f-system.formatString" class="openblock item function">
<div class="title">int playdate->system->formatString(char **ret, const char *format, ...)</div>
<div class="content">
<div class="paragraph">
<p>Allocates a buffer <em>ret</em> and formats a string. Note that the caller is responsible for freeing <em>ret</em>.</p>
</div>
</div>
</div>
<div id="f-system.setMenuImage" class="openblock item function">
<div class="title">void playdate->system->setMenuImage(LCDBitmap* bitmap, int xOffset);</div>
<div class="content">
<div class="paragraph">
<p>A game can optionally provide an image to be displayed alongside the system menu. <em>bitmap</em> must be a 400x240 LCDBitmap. All important content should be in the left half of the image in an area 200 pixels wide, as the menu will obscure the rest. The right side of the image will be visible briefly as the menu animates in and out.</p>
</div>
<div class="paragraph">
<p>Optionally, a non-zero <em>xoffset</em>, can be provided. This must be a number between 0 and 200 and will cause the menu image to animate to a position offset left by xoffset pixels as the menu is animated in.</p>
</div>
<div class="paragraph">
<p>This function could be called in response to the kEventPause <em>event</em> in your implementation of <a href="#_eventHandler">eventHandler()</a>.</p>
</div>
<div class="literalblock">
<div class="title">PDCallbackFunction</div>
<div class="content">
<pre>int PDCallbackFunction(void* userdata);</pre>
</div>
</div>
</div>
</div>
<div id="f-system.setUpdateCallback" class="openblock item function">
<div class="title">void playdate->system->setUpdateCallback(PDCallbackFunction* update, void* userdata)</div>
<div class="content">
<div class="paragraph">
<p>Replaces the default Lua run loop function with a custom update function. The update function should return a non-zero number to tell the system to update the display, or zero if update isn’t needed.</p>
</div>
</div>
</div>
<div id="f-system.drawFPS" class="openblock item function">
<div class="title">void playdate->system->drawFPS(int x, int y)</div>
<div class="content">
<div class="paragraph">
<p>Calculates the current frames per second and draws that value at <em>x, y</em>.</p>
</div>
</div>
</div>
<div id="f-system.getBatteryPercentage" class="openblock item function">
<div class="title">float playdate->system->getBatteryPercentage()</div>
<div class="content">
<div class="paragraph">
<p>Returns a value from 0-100 denoting the current level of battery charge. 0 = empty; 100 = full.</p>
</div>
</div>
</div>
<div id="f-system.getBatteryVoltage" class="openblock item function">
<div class="title">float playdate->system->getBatteryVoltage()</div>
<div class="content">
<div class="paragraph">
<p>Returns the battery&#8217;s current voltage level.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_audio">5.2. Audio</h3>
<div id="f-sound.getCurrentTime" class="openblock item function xref">
<div class="title">uint32_t playdate->sound->getCurrentTime(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the sound engine&#8217;s current time value, in units of sample frames, 44,100 per second.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-sound.getCurrentTime"><code>playdate.sound.getCurrentTime()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-sound.getDefaultChannel" class="openblock item function">
<div class="title">SoundChannel* playdate->sound->getDefaultChannel(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the default channel, where sound sources play if they haven&#8217;t been explicity assigned to a different channel.</p>
</div>
</div>
</div>
<div id="f-sound.addChannel" class="openblock item function">
<div class="title">void playdate->sound->addChannel(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Adds the given channel from the sound engine.</p>
</div>
</div>
</div>
<div id="f-sound.addSource" class="openblock item function">
<div class="title">SoundSource* playdate->sound->addSource(AudioSourceFunction* callback, void* context, int stereo)</div>
<div class="content">
<div class="paragraph">
<p>The <em>callback</em> function you pass in will be called every audio render cycle.</p>
</div>
<div class="literalblock">
<div class="title">AudioSourceFunction</div>
<div class="content">
<pre>int AudioSourceFunction(void* context, int16_t* left, int16_t* right, int len)</pre>
</div>
</div>
<div class="paragraph">
<p>This function should fill the passed-in <em>left</em> buffer (and <em>right</em> if it’s a stereo source) with <em>len</em> samples each and return 1, or return 0 if the source is silent through the cycle.</p>
</div>
</div>
</div>
<div id="f-sound.removeSource" class="openblock item function">
<div class="title">void playdate->sound->removeSource(SoundSource* source)</div>
<div class="content">
<div class="paragraph">
<p>Removes the given <a href="#f-sound.source">SoundSource</a> object from its channel, whether it&#8217;s in the default channel or a channel created with <a href="#f-sound.addChannel">playdate&#8594;sound&#8594;addChannel()</a>.</p>
</div>
</div>
</div>
<div id="f-sound.removeChannel" class="openblock item function">
<div class="title">void playdate->sound->removeChannel(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Removes the given channel from the sound engine.</p>
</div>
</div>
</div>
<div id="f-sound.setMicCallback" class="openblock item function">
<div class="title">void playdate->sound->setMicCallback(AudioInputFunction* callback, void* context, int forceInternal)</div>
<div class="content">
<div class="paragraph">
<p>The <em>callback</em> you pass in will be called every audio cycle.</p>
</div>
<div class="literalblock">
<div class="title">AudioInputFunction</div>
<div class="content">
<pre>int AudioInputFunction(void* context, int16_t* data, int len)</pre>
</div>
</div>
<div class="paragraph">
<p>Your input callback will be called with the recorded audio data, a monophonic stream of samples. The function should return 1 to continue recording, 0 to stop recording. If <em>forceInternal</em> is set, the device microphone is used regardless of whether the headset has a microphone.</p>
</div>
</div>
</div>
<div id="f-sound.getHeadphoneState" class="openblock item function xref">
<div class="title">void playdate->sound->getHeadphoneState(int* headphone, int* mic, int (*changeCallback)(int headphone, int mic))</div>
<div class="content">
<div class="paragraph">
<p>If <em>headphone</em> contains a pointer to an int, the value is set to 1 if headphones are currently plugged in. Likewise, <em>mic</em> is set if the headphones include a microphone. If <em>changeCallback</em> is provided, it will be called when the headset or mic status changes, and audio output will <strong>not</strong> automatically switch from speaker to headphones when headphones are plugged in (and vice versa). In this case, the callback should use <code>playdate&#8594;sound&#8594;setOutputsActive()</code> to change the output if needed.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-sound.getHeadphoneState"><code>playdate.sound.getHeadphoneState()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-sound.setOutputsActive" class="openblock item function xref">
<div class="title">void playdate->sound->setOutputsActive(int headphone, int speaker)</div>
<div class="content">
<div class="paragraph">
<p>Force audio output to the given outputs, regardless of headphone status.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-sound.setOutputsActive"><code>playdate.sound.setOutputsActive()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.channel">Channels</h4>
<div id="f-sound.channel.newChannel" class="openblock item function">
<div class="title">SoundChannel* playdate->sound->channel->newChannel(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new <em>SoundChannel</em> object.</p>
</div>
</div>
</div>
<div id="f-sound.channel.freeChannel" class="openblock item function">
<div class="title">void playdate->sound->channel->freeChannel(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>SoundChannel</em>.</p>
</div>
</div>
</div>
<div id="f-sound.channel.addSource" class="openblock item function">
<div class="title">void playdate->sound->channel->addSource(SoundChannel* channel, SoundSource* source)</div>
<div class="content">
<div class="paragraph">
<p>Adds a <a href="#f-sound.source">SoundSource</a> to the channel. If a source is not assigned to a channel, it plays on the default global channel.</p>
</div>
</div>
</div>
<div id="f-sound.channel.removeSource" class="openblock item function">
<div class="title">int playdate->sound->channel->removeSource(SoundChannel* channel, SoundSource* source)</div>
<div class="content">
<div class="paragraph">
<p>Removes a <a href="#f-sound.source">SoundSource</a> to the channel. Returns 1 if the source was found in (and removed from) the channel, otherwise 0.</p>
</div>
</div>
</div>
<div id="f-sound.channel.addEffect" class="openblock item function">
<div class="title">void playdate->sound->channel->addEffect(SoundChannel* channel, SoundEffect* effect)</div>
<div class="content">
<div class="paragraph">
<p>Adds a <a href="#f-sound.effect">SoundEffect</a> to the channel.</p>
</div>
</div>
</div>
<div id="f-sound.channel.removeEffect" class="openblock item function">
<div class="title">void playdate->sound->channel->removeEffect(SoundChannel* channel, SoundEffect* effect)</div>
<div class="content">
<div class="paragraph">
<p>Removes a <a href="#f-sound.effect">SoundEffect</a> from the channel.</p>
</div>
</div>
</div>
<div id="f-sound.channel.setVolume" class="openblock item function">
<div class="title">void playdate->sound->channel->setVolume(SoundChannel* channel, float volume)</div>
<div class="content">
<div class="paragraph">
<p>Sets the volume for the channel, in the range [0-1].</p>
</div>
</div>
</div>
<div id="f-sound.channel.getVolume" class="openblock item function">
<div class="title">float playdate->sound->channel->getVolume(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Gets the volume for the channel, in the range [0-1].</p>
</div>
</div>
</div>
<div id="f-sound.channel.setVolumeModulator" class="openblock item function">
<div class="title">void playdate->sound->channel->setVolumeModulator(SoundChannel* channel, PDSynthSignalValue* mod)</div>
<div class="content">
<div class="paragraph">
<p>Sets a <a href="#C-sound.signal">signal</a> to modulate the channel volume.</p>
</div>
</div>
</div>
<div id="f-sound.channel.getVolumeModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->channel->getVolumeModulator(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Gets a <a href="#C-sound.signal">signal</a> modulating the channel volume.</p>
</div>
</div>
</div>
<div id="f-sound.channel.setPan" class="openblock item function">
<div class="title">void playdate->sound->channel->setPan(SoundChannel* channel, float pan)</div>
<div class="content">
<div class="paragraph">
<p>Sets the pan parameter for the channel. Valid values are in the range [-1,1], where -1 is left, 0 is center, and 1 is right.</p>
</div>
</div>
</div>
<div id="f-sound.channel.setPanModulator" class="openblock item function">
<div class="title">void playdate->sound->channel->setPanModulator(SoundChannel* channel, PDSynthSignalValue* mod)</div>
<div class="content">
<div class="paragraph">
<p>Sets a <a href="#C-sound.signal">signal</a> to modulate the channel pan.</p>
</div>
</div>
</div>
<div id="f-sound.channel.getPanModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->channel->getPanModulator(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Gets a <a href="#C-sound.signal">signal</a> modulating the channel pan.</p>
</div>
</div>
</div>
<div id="f-sound.channel.addCallbackSource" class="openblock item function">
<div class="title">SoundSource* playdate->sound->channel->addCallbackSource(SoundChannel* channel, AudioSourceFunction* callback, void* context, int stereo)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new <a href="#f-sound.source">SoundSource</a> using the given data provider callback and adds it to the channel.</p>
</div>
<div class="literalblock">
<div class="title">AudioSourceFunction</div>
<div class="content">
<pre>int AudioSourceFunction(void* context, int16_t* left, int16_t* right, int len)</pre>
</div>
</div>
<div class="paragraph">
<p>This function should fill the passed-in <em>left</em> buffer (and <em>right</em> if it’s a stereo source) with <em>len</em> samples each and return 1, or return 0 if the source is silent through the cycle. The caller takes ownership of the allocated SoundSource, and should free it with</p>
</div>
<div class="literalblock">
<div class="content">
<pre>playdate-&gt;system-&gt;realloc(source, NULL);</pre>
</div>
</div>
<div class="paragraph">
<p>when it is not longer in use.</p>
</div>
</div>
</div>
<div id="f-sound.channel.getDryLevelSignal" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->channel->getDryLevelSignal(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Returns a signal that follows the volume of the channel before effects are applied.</p>
</div>
</div>
</div>
<div id="f-sound.channel.getWetLevelSignal" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->channel->getWetLevelSignal(SoundChannel* channel)</div>
<div class="content">
<div class="paragraph">
<p>Returns a signal that follows the volume of the channel after effects are applied.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.source">SoundSource</h4>
<div class="paragraph">
<p>SoundSource is the parent class of FilePlayer, SamplePlayer, PDSynth, DelayLineTap, and PDSynthInstrument. Any objects of those types can be cast to SoundSource type and used in these functions.</p>
</div>
<div id="f-sound.source.setVolume" class="openblock item function">
<div class="title">void playdate->sound->source->setVolume(SoundSource* c, float lvol, float rvol)</div>
<div class="content">
<div class="paragraph">
<p>Sets the playback volume (0.0 - 1.0) for left and right channels of the source.</p>
</div>
</div>
</div>
<div id="f-sound.source.getVolume" class="openblock item function">
<div class="title">void playdate->sound->source->getVolume(SoundSource* c, float* outlvol, float* outrvol)</div>
<div class="content">
<div class="paragraph">
<p>Gets the playback volume (0.0 - 1.0) for left and right channels of the source.</p>
</div>
</div>
</div>
<div id="f-sound.source.isPlaying" class="openblock item function">
<div class="title">int playdate->sound->source->isPlaying(SoundSource* c)</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the source is currently playing.</p>
</div>
</div>
</div>
<div id="f-sound.source.setCompletionCallback" class="openblock item function">
<div class="title">void playdate->sound->source->setCompletionCallback(SoundSource* c, sndCallbackProc callback)</div>
<div class="content">
<div class="literalblock">
<div class="title">sndCallbackProc</div>
<div class="content">
<pre>int sndCallbackProc(SoundSource* c);</pre>
</div>
</div>
<div class="paragraph">
<p>Sets a function to be called when the source has finished playing.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.sample">AudioSample</h4>
<div id="f-sound.sample.newSampleBuffer" class="openblock item function">
<div class="title">AudioSample* playdate->sound->sample->newSampleBuffer(int length)</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new AudioSample with a buffer large enough to load a file of <em>length</em> bytes.</p>
</div>
</div>
</div>
<div id="f-sound.sample.loadIntoSample" class="openblock item function">
<div class="title">void playdate->sound->sample->loadIntoSample(AudioSample* sample, const char* path)</div>
<div class="content">
<div class="paragraph">
<p>Loads the sound data from the file at <em>path</em> into an existing AudioSample, <em>sample</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sample.loadFile" class="openblock item function">
<div class="title">AudioSample* playdate->sound->sample->loadFile(const char* path)</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new AudioSample, with the sound data loaded in memory. If there is no file at <em>path</em>, the function returns null.</p>
</div>
</div>
</div>
<div id="f-sound.sample.newSampleFromData" class="openblock item function">
<div class="title">AudioSample* playdate->sound->sample->newSampleFromData(uint8_t* data, SoundFormat format, uint32_t sampleRate, int byteCount)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new AudioSample referencing the given audio data. The sample keeps a pointer to the data instead of copying it, so the data must remain valid while the sample is active. <em>format</em> is one of the following values:</p>
</div>
<div class="literalblock">
<div class="title">SoundFormat</div>
<div class="content">
<pre>typedef enum
{
	kSound8bitMono = 0,
	kSound8bitStereo = 1,
	kSound16bitMono = 2,
	kSound16bitStereo = 3,
	kSoundADPCMMono = 4,
	kSoundADPCMStereo = 5
} SoundFormat;</pre>
</div>
</div>
<div class="paragraph">
<p><code>pd_api_sound.h</code> also provides some helper macros and functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="c"><span class="preprocessor">#define</span> SoundFormatIsStereo(f) ((f)&amp;<span class="integer">1</span>)
<span class="preprocessor">#define</span> SoundFormatIs16bit(f) ((f)&gt;=kSound16bitMono)
<span class="directive">static</span> <span class="directive">inline</span> uint32_t SoundFormat_bytesPerFrame(SoundFormat fmt);</code></pre>
</div>
</div>
</div>
</div>
<div id="m-" class="openblock item method">
<div class="title">void playdate->sound->sample->getData(AudioSample* sample, uint8_t** data, SoundFormat* format, uint32_t* sampleRate, uint32_t* bytelength)</div>
<div class="content">
<div class="paragraph">
<p>Retrieves the sample&#8217;s data, format, sample rate, and data length.</p>
</div>
</div>
</div>
<div id="f-sound.sample.freeSample" class="openblock item function">
<div class="title">void playdate->sound->sample->freeSample(AudioSample* sample)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>sample</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sample.getLength" class="openblock item function">
<div class="title">float playdate->sound->sample->getLength(AudioSample* sample)</div>
<div class="content">
<div class="paragraph">
<p>Returns the length, in seconds, of <em>sample</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.fileplayer">FilePlayer</h4>
<div id="f-sound.fileplayer.newPlayer" class="openblock item function">
<div class="title">FilePlayer* playdate->sound->fileplayer->newPlayer(void);</div>
<div class="content">
<div class="paragraph">
<p>Allocates a new FilePlayer.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.freePlayer" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->freePlayer(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.loadIntoPlayer" class="openblock item function">
<div class="title">int playdate->sound->fileplayer->loadIntoPlayer(FilePlayer* player, const char* path);</div>
<div class="content">
<div class="paragraph">
<p>Prepares <em>player</em> to stream the file at <em>path</em>. Returns 1 if the file exists, otherwise 0.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.pause" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->pause(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Pauses the file <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.play" class="openblock item function">
<div class="title">int playdate->sound->fileplayer->play(FilePlayer* player, int repeat);</div>
<div class="content">
<div class="paragraph">
<p>Starts playing the file <em>player</em>. If <em>repeat</em> is greater than one, it loops the given number of times. If zero, it loops endlessly until it is stopped with <a href="#f-sound.fileplayer.stop">playdate->sound->fileplayer->stop()</a>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.isPlaying" class="openblock item function">
<div class="title">int playdate->sound->fileplayer->isPlaying(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Returns one if <em>player</em> is playing, zero if not.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setBufferLength" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setBufferLength(FilePlayer* player, float bufferLen);</div>
<div class="content">
<div class="paragraph">
<p>Sets the buffer length of <em>player</em> to <em>bufferLen</em> seconds;</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.getLength" class="openblock item function">
<div class="title">float playdate->sound->fileplayer->getLength(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Returns the length, in seconds, of the file loaded into <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setFinishCallback" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setFinishCallback(FilePlayer* player, sndCallbackProc callback);</div>
<div class="content">
<div class="paragraph">
<p>Sets a function to be called when playback has completed. This is an alias for <a href="#f-sound.source.setFinishCallback">playdate&#8594;sound&#8594;source&#8594;setFinishCallback()</a>.</p>
</div>
<div id="_sndCallbackProc" class="literalblock">
<div class="title">sndCallbackProc</div>
<div class="content">
<pre>typedef void sndCallbackProc(SoundSource* c);</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.fileplayer.didUnderrun" class="openblock item function">
<div class="title">int playdate->sound->fileplayer->didUnderrun(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Returns one if <em>player</em> has underrun, zero if not.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setLoopRange" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setLoopRange(FilePlayer* player, float start, float end);</div>
<div class="content">
<div class="paragraph">
<p>Sets the <em>start</em> and <em>end</em> of the loop region for playback, in seconds. If <em>end</em> is omitted, the end of the file is used.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setOffset" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setOffset(FilePlayer* player, float offset);</div>
<div class="content">
<div class="paragraph">
<p>Sets the current <em>offset</em> in seconds.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.getOffset" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->getOffset(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Gets the current offset in seconds for <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setRate" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setRate(FilePlayer* player, float rate)</div>
<div class="content">
<div class="paragraph">
<p>Sets the playback <em>rate</em> for the <em>player</em>. 1.0 is normal speed, 0.5 is down an octave, 2.0 is up an octave, etc. Unlike sampleplayers, fileplayers can&#8217;t play in reverse (i.e., rate &lt; 0).</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.getRate" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->getRate(FilePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Gets the playback rate for <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setStopOnUnderrun" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setStopOnUnderrun(FilePlayer* player, int flag)</div>
<div class="content">
<div class="paragraph">
<p>If <em>flag</em> evaluates to true, the <em>player</em> will restart playback (after an audible stutter) as soon as data is available.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.setVolume" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->setVolume(FilePlayer* player, float left, float right);</div>
<div class="content">
<div class="paragraph">
<p>Sets the playback volume for left and right channels of <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.getVolume" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->getVolume(FilePlayer* player, float* left, float* right);</div>
<div class="content">
<div class="paragraph">
<p>Gets the left and right channel playback volume for <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.stop" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->stop(FilePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Stops playing the file.</p>
</div>
</div>
</div>
<div id="f-sound.fileplayer.fadeVolume" class="openblock item function">
<div class="title">void playdate->sound->fileplayer->fadeVolume(FilePlayer* player, float left, float right, int32_t len, sndCallbackProc finishCallback);</div>
<div class="content">
<div class="paragraph">
<p>Changes the volume of the fileplayer to <em>left</em> and <em>right</em> over a length of <em>len</em> sample frames, then calls the provided callback (if set).</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.sampleplayer">SamplePlayer</h4>
<div id="f-sound.sampleplayer.getLength" class="openblock item function">
<div class="title">float playdate->sound->sampleplayer->getLength(SamplePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Returns the length, in seconds, of the sample assigned to <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.isPlaying" class="openblock item function">
<div class="title">int playdate->sound->sampleplayer->isPlaying(SamplePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Returns one if <em>player</em> is playing a sample, zero if not.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.newSamplePlayer" class="openblock item function">
<div class="title">SamplePlayer* playdate->sound->sampleplayer->newSamplePlayer(void)</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new SamplePlayer.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.play" class="openblock item function">
<div class="title">int playdate->sound->sampleplayer->play(SamplePlayer* player, int repeat, float rate)</div>
<div class="content">
<div class="paragraph">
<p>Starts playing the sample in <em>player</em>.</p>
</div>
<div class="paragraph">
<p>If <em>repeat</em> is greater than one, it loops the given number of times. If zero, it loops endlessly until it is stopped with <a href="#f-sound.sampleplayer.stop">playdate-&gt;sound-&gt;sampleplayer-&gt;stop()</a>. If negative one, it does ping-pong looping.</p>
</div>
<div class="paragraph">
<p>Sets the playback <em>rate</em> for the sample. 1.0 is normal speed, 0.5 is down an octave, 2.0 is up an octave, etc.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setFinishCallback" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setFinishCallback(SamplePlayer* player, sndCallbackProc callback)</div>
<div class="content">
<div class="paragraph">
<p>Sets a function to be called when playback has completed. See <a href="#_sndCallbackProc">sndCallbackProc</a>.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setOffset" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setOffset(SamplePlayer* player, float offset)</div>
<div class="content">
<div class="paragraph">
<p>Sets the current <em>offset</em> of the SamplePlayer, in seconds.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.getOffset" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->getOffset(SamplePlayer* player);</div>
<div class="content">
<div class="paragraph">
<p>Gets the current offset in seconds for <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setPlayRange" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setPlayRange(SamplePlayer* player, int start, int end)</div>
<div class="content">
<div class="paragraph">
<p>When used with a repeat of -1, does ping-pong looping, with a <em>start</em> and <em>end</em> position in frames.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setPaused" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setPaused(SamplePlayer* player, int paused)</div>
<div class="content">
<div class="paragraph">
<p>Pauses or resumes playback.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setRate" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setRate(SamplePlayer* player, float rate)</div>
<div class="content">
<div class="paragraph">
<p>Sets the playback <em>rate</em> for the <em>player</em>. 1.0 is normal speed, 0.5 is down an octave, 2.0 is up an octave, etc. A negative rate produces backwards playback for PCM files, but does not work for ADPCM-encoded files.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.getRate" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->getRate(SamplePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Gets the playback rate for <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setSample" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setSample(SamplePlayer* player, AudioSample* sample)</div>
<div class="content">
<div class="paragraph">
<p>Assigns <em>sample</em> to <em>player</em>.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.setVolume" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->setVolume(SamplePlayer* player, float left, float right)</div>
<div class="content">
<div class="paragraph">
<p>Sets the playback volume for left and right channels.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.getVolume" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->getVolume(SamplePlayer* player, float* left, float* right)</div>
<div class="content">
<div class="paragraph">
<p>Gets the current left and right channel volume of the sampleplayer.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.stop" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->stop(SamplePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Stops playing the sample.</p>
</div>
</div>
</div>
<div id="f-sound.sampleplayer.freePlayer" class="openblock item function">
<div class="title">void playdate->sound->sampleplayer->freePlayer(SamplePlayer* player)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>player</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.synth">PDSynth</h4>
<div id="f-sound.synth.newSynth" class="openblock item function">
<div class="title">PDSynth* playdate->sound->synth->newSynth(void)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new synth object.</p>
</div>
</div>
</div>
<div id="f-sound.synth.freeSynth" class="openblock item function">
<div class="title">void playdate->sound->synth->freeSynth(PDSynth* synth)</div>
<div class="content">
<div class="paragraph">
<p>Frees a synth object, first removing it from the sound engine if needed.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setWaveform" class="openblock item function">
<div class="title">void playdate->sound->synth->setWaveform(PDSynth* synth, SoundWaveform wave)</div>
<div class="content">
<div class="paragraph">
<p>Sets the waveform of the synth. The SoundWaveform enum contains the following values:</p>
</div>
<div class="literalblock">
<div class="title">SoundWaveform</div>
<div class="content">
<pre>typedef enum
{
	kWaveformSquare,
	kWaveformTriangle,
	kWaveformSine,
	kWaveformNoise,
	kWaveformSawtooth,
	kWaveformPOPhase,
	kWaveformPODigital,
	kWaveformPOVosim
} SoundWaveform;</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.synth.setGenerator" class="openblock item function">
<div class="title">void playdate->sound->synth->setGenerator(PDSynth* synth, int stereo, synthRenderFunc* render, synthNoteOnFunc* noteOn, synthReleaseFunc* release, synthSetParameterFunc* setparam, synthDeallocFunc* dealloc, void* userdata)</div>
<div class="content">
<div class="literalblock">
<div class="title">GeneratorFunctions</div>
<div class="content">
<pre>typedef int (*synthRenderFunc)(void* userdata, int32_t* left, int32_t* right, int nsamples, uint32_t rate, int32_t drate);
typedef void (*synthNoteOnFunc)(void* userdata, MIDINote note, float velocity, float len); // len == -1 if indefinite
typedef void (*synthReleaseFunc)(void* userdata, int ended);
typedef int (*synthSetParameterFunc)(void* userdata, int parameter, float value);
typedef void (*synthDeallocFunc)(void* userdata);</pre>
</div>
</div>
<div class="paragraph">
<p>Provides custom waveform generator functions for the synth. <em>synthRenderFunc</em>, the data provider callback, is the only required function. <em>left</em> (and <em>right</em> if <em>setGenerator()</em> was called with the stereo flag set) are sample buffers in Q8.24 format. <em>rate</em> is the amount to change a (Q32) phase accumulator each sample, and <em>drate</em> is the amount to change <em>rate</em> each sample. Custom synths can safely ignore this and use the <em>note</em> paramter in the noteOn function to handle pitch, but synth&#8594;setFrequencyModulator() won&#8217;t work as expected. These functions are called on the audio render thread, so they should return as quickly as possible.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setSample" class="openblock item function">
<div class="title">void playdate->sound->synth->setSample(PDSynth* synth, AudioSample* sample, uint32_t sustainStart, uint32_t sustainEnd)</div>
<div class="content">
<div class="paragraph">
<p>Provides a sample for the synth to play. Sample data must be uncompressed PCM, not ADPCM.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setAttackTime" class="openblock item function">
<div class="title">void playdate->sound->synth->setAttackTime(PDSynth* synth, float attack)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.setDecayTime" class="openblock item function">
<div class="title">void playdate->sound->synth->setDecayTime(PDSynth* synth, float decay)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.setSustainLevel" class="openblock item function">
<div class="title">void playdate->sound->synth->setSustainLevel(PDSynth* synth, float sustain)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.setReleaseTime" class="openblock item function">
<div class="title">void playdate->sound->synth->setReleaseTime(PDSynth* synth, float release)</div>
<div class="content">
<div class="paragraph">
<p>Sets the parameters of the synth&#8217;s ADSR envelope.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setTranspose" class="openblock item function">
<div class="title">void playdate->sound->synth->setTranspose(PDSynth* synth, float halfSteps)</div>
<div class="content">
<div class="paragraph">
<p>Transposes the synth&#8217;s output by the given number of half steps. For example, if the transpose is set to 2 and a C note is played, the synth will output a D instead.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setFrequencyModulator" class="openblock item function">
<div class="title">void playdate->sound->synth->setFrequencyModulator(PDSynth* synth, PDSynthSignalValue* mod)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.getFrequencyModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->synth->getFrequencyModulator(PDSynth* synth)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the synth&#8217;s frequency. The signal is scaled so that a value of 1 doubles the synth pitch (i.e. an octave up) and -1 halves it (an octave down).</p>
</div>
</div>
</div>
<div id="f-sound.synth.setAmplitudeModulator" class="openblock item function">
<div class="title">void playdate->sound->synth->setAmplitudeModulator(PDSynth* synth, PDSynthSignalValue* mod)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.getAmplitudeModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->synth->getAmplitudeModulator(PDSynth* synth)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the synth&#8217;s output amplitude.</p>
</div>
</div>
</div>
<div id="f-sound.synth.getParameterCount" class="openblock item function">
<div class="title">int playdate->sound->synth->setParameter(PDSynth* synth)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of parameters advertised by the synth.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setParameter" class="openblock item function">
<div class="title">int playdate->sound->synth->setParameter(PDSynth* synth, int num, float value)</div>
<div class="content">
<div class="paragraph">
<p>Sets the (0-based) parameter at position <em>num</em> to the given value. Returns 0 if <em>num</em> is not a valid parameter index.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setParameterModulator" class="openblock item function">
<div class="title">int playdate->sound->synth->setParameterModulator(PDSynth* synth, int num, PDSynthSignalValue* mod)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.getParameterModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->synth->newSynth(PDSynth* synth, int num)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the parameter at index <em>num</em>.</p>
</div>
</div>
</div>
<div id="f-sound.synth.playNote" class="openblock item function">
<div class="title">void playdate->sound->synth->playNote(PDSynth* synth, float freq, float vel, float len, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>Plays a note on the synth, at the given frequency. Specify <em>len</em> = -1 to leave the note playing until a subsequent noteOff() call. If <em>when</em> is 0, the note is played immediately, otherwise the note is scheduled for the given time. Use <a href="#f-sound.getCurrentTime">playdate&#8594;sound&#8594;getCurrentTime()</a> to get the current time.</p>
</div>
</div>
</div>
<div id="f-sound.synth.playMIDINote" class="openblock item function">
<div class="title">void playdate->sound->synth->playMIDINote(PDSynth* synth, MIDINote note, float vel, float len, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>The same as <a href="#f-sound.synth.playNote">playNote</a> but uses MIDI note (where 60 = C4) instead of frequency.</p>
</div>
</div>
</div>
<div id="f-sound.synth.noteOff" class="openblock item function">
<div class="title">void playdate->sound->synth->noteOff(PDSynth* synth, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>Sends a note off event to the synth, either immediately (<em>when</em> = 0) or at the scheduled time.</p>
</div>
</div>
</div>
<div id="f-sound.synth.setVolume" class="openblock item function">
<div class="title">void playdate->sound->synth->setVolume(PDSynth* synth, float lvol, float rvol)</div>
<div class="content">

</div>
</div>
<div id="f-sound.synth.getVolume" class="openblock item function">
<div class="title">void playdate->sound->synth->getVolume(PDSynth* synth, float* outlvol, float* outrvol)</div>
<div class="content">
<div class="paragraph">
<p>Sets and gets the playback volume (0.0 - 1.0) for left and right channels of the synth. This is equivalent to</p>
</div>
<div class="literalblock">
<div class="content">
<pre>playdate-&gt;sound-&gt;source-&gt;setVolume((SoundSource*)synth, lvol, rvol);
playdate-&gt;sound-&gt;source-&gt;getVolume((SoundSource*)synth, &amp;lvol, &amp;rvol);</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.synth.isPlaying" class="openblock item function">
<div class="title">int playdate->sound->synth->isPlaying(PDSynth* synth)</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the synth is currently playing.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.PDSynthInstrument">PDSynthInstrument</h4>
<div class="paragraph">
<p>PDSynthInstrument collects a number of PDSynth objects together to provide polyphony.</p>
</div>
<div id="f-sound.instrument.newInstrument" class="openblock item function">
<div class="title">PDSynthInstrument* playdate->sound->instrument->newSequence(void)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new PDSynthInstrument object.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.freeInstrument" class="openblock item function">
<div class="title">void playdate->sound->instrument->freeInstrument(PDSynthInstrument* instrument)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given instrument, first removing it from the sound engine if needed.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.addVoice" class="openblock item function">
<div class="title">int playdate->sound->instrument->addVoice(PDSynthInstrument* instrument, PDSynth* synth, MIDINote rangeStart, MIDINote rangeEnd, float transpose)</div>
<div class="content">
<div class="paragraph">
<p>Adds the given <a href="#C-sound.synth">PDSynth</a> to the instrument. The synth will respond to playNote events between <em>rangeState</em> and <em>rangeEnd</em>, inclusive. The <em>transpose</em> argument is in half-step units, and is added to the instrument&#8217;s <a href="#f-sound.instrument.setTranspose">transpose</a> parameter. The function returns 1 if successful, or 0 if the synth is already in another instrument or channel.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.playNote" class="openblock item function">
<div class="title">PDSynth* playdate->sound->instrument->playNote(PDSynthInstrument* instrument, float frequency, float vel, float len, uint32_t when)</div>
<div class="content">

</div>
</div>
<div id="f-sound.instrument.playMIDINote" class="openblock item function">
<div class="title">PDSynth* playdate->sound->instrument->playMIDINote(PDSynthInstrument* instrument, MIDINote note, float vel, float len, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>The instrument passes the playNote/playMIDINote() event to the synth in its collection that has been off for the longest, or has been playing longest if all synths are currently playing. See also <a href="#f-sound.synth.playNote">playdate&#8594;sound&#8594;synth&#8594;playNote()</a>. The PDSynth that received the playNote event is returned.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.noteOff" class="openblock item function">
<div class="title">void playdate->sound->instrument->noteOff(PDSynthInstrument* instrument, MIDINote note, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>Forwards the noteOff() event to the synth currently playing the given note. See also <a href="#f-sound.synth.noteOff">playdate&#8594;sound&#8594;synth&#8594;noteOff()</a>.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.setPitchBend" class="openblock item function">
<div class="title">void playdate->sound->instrument->setPitchBend(PDSynthInstrument* instrument, float bend)</div>
<div class="content">

</div>
</div>
<div id="f-sound.instrument.setPitchBendRange" class="openblock item function">
<div class="title">void playdate->sound->instrument->setPitchBendRange(PDSynthInstrument* instrument, float halfSteps)</div>
<div class="content">
<div class="paragraph">
<p>Sets the pitch bend and pitch bend range to be applied to the voices in the instrument.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.setTranspose" class="openblock item function">
<div class="title">void playdate->sound->instrument->setTranspose(PDSynthInstrument* instrument, float halfSteps)</div>
<div class="content">
<div class="paragraph">
<p>Sets the transpose parameter for all voices in the instrument.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.allNotesOff" class="openblock item function">
<div class="title">void playdate->sound->instrument->allNotesOff(PDSynthInstrument* instrument, uint32_t when)</div>
<div class="content">
<div class="paragraph">
<p>Sends a noteOff event to all voices in the instrument.</p>
</div>
</div>
</div>
<div id="f-sound.instrument.setVolume" class="openblock item function">
<div class="title">void playdate->sound->instrument->setVolume(PDSynthInstrument* instrument, float lvol, float rvol)</div>
<div class="content">

</div>
</div>
<div id="f-sound.instrument.getVolume" class="openblock item function">
<div class="title">void playdate->sound->instrument->getVolume(PDSynthInstrument* instrument, float* outlvol, float* outrvol)</div>
<div class="content">
<div class="paragraph">
<p>Sets and gets the playback volume (0.0 - 1.0) for left and right channels of the synth. This is equivalent to</p>
</div>
<div class="literalblock">
<div class="content">
<pre>playdate-&gt;sound-&gt;source-&gt;setVolume((SoundSource*)instrument, lvol, rvol);
playdate-&gt;sound-&gt;source-&gt;getVolume((SoundSource*)instrument, &amp;lvol, &amp;rvol);</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.instrument.activeVoiceCount" class="openblock item function">
<div class="title">int playdate->sound->instrument->activeVoiceCount(PDSynthInstrument* instrument)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of voices in the instrument currently playing.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.signal">Signals</h4>
<div class="paragraph">
<p>A PDSynthSignalValue represents a signal that can be used as a modulator. Its PDSynthSignal subclass is used for "active" signals that change their values automatically. PDSynthLFO and PDSynthEnvelope are subclasses of PDSynthSignal.</p>
</div>
<div id="f-sound.signal.newSignal" class="openblock item function">
<div class="title">void playdate->sound->signal->newSignal(signalStepFunc step, signalNoteOnFunc noteOn, signalNoteOffFunc noteOff, signalDeallocFunc dealloc, void* userdata)</div>
<div class="content">
<div class="literalblock">
<div class="title">CustomSignalFunctions</div>
<div class="content">
<pre>typedef float (*signalStepFunc)(void* userdata, int* iosamples, float* ifval);
typedef void (*signalNoteOnFunc)(void* userdata, MIDINote note, float vel, float len); // len = -1 for indefinite
typedef void (*signalNoteOffFunc)(void* userdata, int stopped, int offset); // ended = 0 for note release, = 1 when note stops playing
typedef void (*signalDeallocFunc)(void* userdata);</pre>
</div>
</div>
<div class="paragraph">
<p>Provides a custom implementation for the signal. <em>signalStepFunc step</em> is the only required function, returning the value at the end of the current frame. When called, the <em>ioframes</em> pointer contains the number of samples until the end of the frame. If the signal needs to provide a value in the middle of the frame (e.g. an LFO that needs to be sample-accurate) it should return the "interframe" value in <em>ifval</em> and set <em>iosamples</em> to the sample offset of the value. The functions are called on the audio render thread, so they should return as quickly as possible.</p>
</div>
</div>
</div>
<div id="f-sound.signal.freeSignal" class="openblock item function">
<div class="title">void (*freeSignal)(PDSynthSignal* signal);</div>
<div class="content">
<div class="paragraph">
<p>Frees a signal created with <em>playdate&#8594;sound&#8594;signal&#8594;newSignal()</em>.</p>
</div>
</div>
</div>
<div id="f-sound.signal.getValue" class="openblock item function">
<div class="title">float (*getValue)(PDSynthSignal* signal);</div>
<div class="content">
<div class="paragraph">
<p>Returns the current output value of <em>signal</em>. The signal can be a custom signal created with newSignal(), or any of the PDSynthSignal subclasses.</p>
</div>
</div>
</div>
<div id="f-sound.signal.setValueOffset" class="openblock item function">
<div class="title">void (*setValueOffset)(PDSynthSignal* signal, float offset);</div>
<div class="content">
<div class="paragraph">
<p>Offsets the signal&#8217;s output by the given amount.</p>
</div>
</div>
</div>
<div id="f-sound.signal.setValueScale" class="openblock item function">
<div class="title">void (*setValueScale)(PDSynthSignal* signal, float scale);</div>
<div class="content">
<div class="paragraph">
<p>Scales the signal&#8217;s output by the given factor. The scale is applied before the offset.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.lfo">LFO</h4>
<div id="f-sound.lfo.newLFO" class="openblock item function">
<div class="title">PDSynthLFO* playdate->sound->newLFO(LFOType type)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new LFO object, which can be used to modulate sounds. The <em>type</em> argument is one of the following values:</p>
</div>
<div class="literalblock">
<div class="title">LFOType</div>
<div class="content">
<pre>typedef enum
{
	kLFOTypeSquare,
	kLFOTypeTriangle,
	kLFOTypeSine,
	kLFOTypeSampleAndHold,
	kLFOTypeSawtoothUp,
	kLFOTypeSawtoothDown,
	kLFOTypeArpeggiator,
	kLFOTypeFunction
} LFOType;</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.lfo.freeLFO" class="openblock item function">
<div class="title">void playdate->sound->lfo->freeLFO(PDSynthLFO* lfo)</div>
<div class="content">
<div class="paragraph">
<p>Frees the LFO.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setType" class="openblock item function">
<div class="title">void playdate->sound->lfo->setType(PDSynthLFO* lfo, LFOType type)</div>
<div class="content">
<div class="paragraph">
<p>Sets the LFO shape to one of the values given above.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setRate" class="openblock item function">
<div class="title">void playdate->sound->lfo->setRate(PDSynthLFO* lfo, float rate)</div>
<div class="content">
<div class="paragraph">
<p>Sets the LFO&#8217;s rate, in cycles per second.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setPhase" class="openblock item function">
<div class="title">void playdate->sound->lfo->setPhase(PDSynthLFO* lfo, float phase)</div>
<div class="content">
<div class="paragraph">
<p>Sets the LFO&#8217;s phase.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setCenter" class="openblock item function">
<div class="title">void playdate->sound->lfo->setCenter(PDSynthLFO* lfo, float center)</div>
<div class="content">

</div>
</div>
<div id="f-sound.lfo.setDepth" class="openblock item function">
<div class="title">void playdate->sound->lfo->setDepth(PDSynthLFO* lfo, float depth)</div>
<div class="content">
<div class="paragraph">
<p>Sets the center or depth of the LFO.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setArpeggiation" class="openblock item function">
<div class="title">void playdate->sound->lfo->setArpeggiation(PDSynthLFO* lfo, int nSteps, float* steps)</div>
<div class="content">
<div class="paragraph">
<p>Sets the LFO type to arpeggio, where the given values are in half-steps from the center note. For example, the sequence (0, 4, 7, 12) plays the notes of a major chord.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setFunction" class="openblock item function">
<div class="title">void playdate->sound->lfo->setFunction(PDSynthLFO* lfo, float (*lfoFunc)(PDSynthLFO* lfo, void* userdata), void* userdata, int interpolate)</div>
<div class="content">
<div class="paragraph">
<p>Provides a custom function for LFO values.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setDelay" class="openblock item function">
<div class="title">void playdate->sound->lfo->setDelay(PDSynthLFO* lfo, float holdoff, float ramptime)</div>
<div class="content">
<div class="paragraph">
<p>Sets an initial holdoff time for the LFO where the LFO remains at its center value, and a ramp time where the value increases linearly to its maximum depth. Values are in seconds.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setRetrigger" class="openblock item function">
<div class="title">void playdate->sound->lfo->setRetrigger(PDSynthLFO* lfo, int flag)</div>
<div class="content">
<div class="paragraph">
<p>If retrigger is on, the LFO&#8217;s phase is reset to 0 when a synth using the LFO starts playing a note.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.getValue" class="openblock item function">
<div class="title">float playdate->sound->lfo->getValue(PDSynthLFO* lfo)</div>
<div class="content">
<div class="paragraph">
<p>Return the current output value of the LFO.</p>
</div>
</div>
</div>
<div id="f-sound.lfo.setGlobal" class="openblock item function">
<div class="title">float playdate->sound->lfo->setGlobal(PDSynthLFO* lfo, int global)</div>
<div class="content">
<div class="paragraph">
<p>If <em>global</em> is set, the LFO is continuously updated whether or not it&#8217;s currently in use.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.envelope">Envelope</h4>
<div id="f-sound.envelope.newEnvelope" class="openblock item function">
<div class="title">PDSynthEnvelope* playdate->sound->envelope->newEnvelope(float attack, float decay, float sustain, float release)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new envelope with the given parameters.</p>
</div>
</div>
</div>
<div id="f-sound.envelope.freeEnvelope" class="openblock item function">
<div class="title">void playdate->sound->envelope->freeEnvelope(PDSynthEnvelope* env)</div>
<div class="content">
<div class="paragraph">
<p>Frees the envelope.</p>
</div>
</div>
</div>
<div id="f-sound.envelope.setAttack" class="openblock item function">
<div class="title">void playdate->sound->envelope->setAttack(PDSynthEnvelope* env, float attack)</div>
<div class="content">

</div>
</div>
<div id="f-sound.envelope.setDecay" class="openblock item function">
<div class="title">void playdate->sound->envelope->setDecay(PDSynthEnvelope* env, float decay)</div>
<div class="content">

</div>
</div>
<div id="f-sound.envelope.setSustain" class="openblock item function">
<div class="title">void playdate->sound->envelope->setSustain(PDSynthEnvelope* env, float sustain)</div>
<div class="content">

</div>
</div>
<div id="f-sound.envelope.setRelease" class="openblock item function">
<div class="title">void playdate->sound->envelope->setRelease(PDSynthEnvelope* env, float release)</div>
<div class="content">
<div class="paragraph">
<p>Sets the ADSR parameters of the envelope.</p>
</div>
</div>
</div>
<div id="f-sound.envelope.setLegato" class="openblock item function">
<div class="title">void playdate->sound->envelope->setLegato(PDSynthEnvelope* env, int flag)</div>
<div class="content">
<div class="paragraph">
<p>Sets whether to use legato phrasing for the envelope. If the legato flag is set, when the envelope is re-triggered before it&#8217;s released, it remains in the sustain phase instead of jumping back to the attack phase.</p>
</div>
</div>
</div>
<div id="f-sound.envelope.setRetrigger" class="openblock item function">
<div class="title">void playdate->sound->envelope->setRetrigger(PDSynthEnvelope* env, int flag)</div>
<div class="content">
<div class="paragraph">
<p>If retrigger is on, the envelope always starts from 0 when a note starts playing, instead of the current value if it&#8217;s active.</p>
</div>
</div>
</div>
<div id="f-sound.envelope.getValue" class="openblock item function">
<div class="title">float playdate->sound->envelope->getValue(PDSynthEnvelope* env)</div>
<div class="content">
<div class="paragraph">
<p>Return the current output value of the envelope.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.effect">SoundEffect</h4>
<div class="paragraph">
<p><em>SoundEffect</em> is the parent class of the sound effect types <a href="#C-sound.twoPoleFilter">TwoPoleFilter</a>, <a href="#C-sound.onePoleFilter">OnePoleFilter</a>, <a href="#C-sound.bitCrusher">BitCrusher</a>, <a href="#C-sound.ringModulator">RingModulator</a>, <a href="#C-sound.overdrive">Overdrive</a>, and <a href="#C-sound.delayLine">DelayLine</a></p>
</div>
<div id="f-sound.effect.newEffect" class="openblock item function">
<div class="title">SoundEffect* playdate->sound->effect->newEffect(effectProc* proc, void* userdata)</div>
<div class="content">
<div class="literalblock">
<div class="title">effectProc</div>
<div class="content">
<pre>typedef int effectProc(SoundEffect* e, int32_t* left, int32_t* right, int nsamples, int bufactive);</pre>
</div>
</div>
<div class="paragraph">
<p>Creates a new effect using the given processing function. <em>bufactive</em> is 1 if samples have been set in the left or right buffers. The function should return 1 if it changed the buffer samples, otherwise 0. <em>left</em> and <em>right</em> (if the effect is on a stereo channel) are sample buffers in Q8.24 format.</p>
</div>
</div>
</div>
<div id="f-sound.effect.freeEffect" class="openblock item function">
<div class="title">void playdate->sound->effect->freeEffect(SoundEffect* effect)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.setMix" class="openblock item function">
<div class="title">void playdate->sound->effect->setMix(SoundEffect* effect, float level)</div>
<div class="content">
<div class="paragraph">
<p>Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix (which is useful if you&#8217;re using a delay line with taps and don&#8217;t want to hear the delay line itself).</p>
</div>
</div>
</div>
<div id="f-sound.effect.setMixModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->setMixModulator(SoundEffect* effect, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.getMixModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->getMixModulator(SoundEffect* effect)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the effect&#8217;s mix level.</p>
</div>
</div>
</div>
<div id="f-sound.effect.setUserdata" class="openblock item function">
<div class="title">void playdate->sound->effect->setUserdata(SoundEffect* effect, void* userdata)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.getUserdata" class="openblock item function">
<div class="title">void* playdate->sound->effect->getUserdata(SoundEffect* effect)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a userdata value for the effect.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.twoPoleFilter">TwoPoleFilter</h4>
<div id="f-sound.effect.twoPoleFilter.newFilter" class="openblock item function">
<div class="title">TwoPoleFilter* playdate->sound->effect->twoPoleFilter->newFilter(void)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new two pole filter effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.freeFilter" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->freeFilter(TwoPoleFilter* filter)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given filter.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setType" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setType(TwoPoleFilter* filter, TwoPoleFilterType type)</div>
<div class="content">
<div class="literalblock">
<div class="title">TwoPoleFilterType</div>
<div class="content">
<pre>typedef enum
{
	kFilterTypeLowPass,
	kFilterTypeHighPass,
	kFilterTypeBandPass,
	kFilterTypeNotch,
	kFilterTypePEQ,
	kFilterTypeLowShelf,
	kFilterTypeHighShelf
} TwoPoleFilterType;</pre>
</div>
</div>
<div class="paragraph">
<p>Sets the type of the filter.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setFrequency" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setFrequency(TwoPoleFilter* filter, float frequency)</div>
<div class="content">
<div class="paragraph">
<p>Sets the center/corner frequency of the filter. Value is in Hz.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setFrequencyModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setFrequencyModulator(TwoPoleFilter* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.twoPoleFilter.getFrequencyModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->twoPoleFilter->getFrequencyModulator(TwoPoleFilter* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the effect&#8217;s frequency. The signal is scaled so that a value of 1.0 corresponds to half the sample rate.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setGain" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setGain(TwoPoleFilter* filter, float gain)</div>
<div class="content">
<div class="paragraph">
<p>Sets the filter gain.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setResonance" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setResonance(TwoPoleFilter* filter, float resonance)</div>
<div class="content">
<div class="paragraph">
<p>Sets the filter resonance.</p>
</div>
</div>
</div>
<div id="f-sound.effect.twoPoleFilter.setResonanceModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->twoPoleFilter->setResonanceModulator(TwoPoleFilter* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.twoPoleFilter.getResonanceModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->twoPoleFilter->getResonanceModulator(TwoPoleFilter* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the filter resonance.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.onePoleFilter">OnePoleFilter</h4>
<div class="paragraph">
<p>The one pole filter is a simple low/high pass filter, with a single parameter describing the cutoff frequency.</p>
</div>
<div id="f-sound.effect.onePoleFilter.newFilter" class="openblock item function">
<div class="title">OnePoleFilter* playdate->sound->effect->onePoleFilter->newFilter(void)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new one pole filter.</p>
</div>
</div>
</div>
<div id="f-sound.effect.onePoleFilter.freeFilter" class="openblock item function">
<div class="title">void playdate->sound->effect->onePoleFilter->freeFilter(OnePoleFilter* filter)</div>
<div class="content">
<div class="paragraph">
<p>Frees the filter.</p>
</div>
</div>
</div>
<div id="f-sound.effect.onePoleFilter.setParameter" class="openblock item function">
<div class="title">void playdate->sound->effect->onePoleFilter->setParameter(OnePoleFilter* filter, float parameter)</div>
<div class="content">
<div class="paragraph">
<p>Sets the filter&#8217;s single parameter (cutoff frequency) to <em>p</em>. Values above 0 (up to 1) are high-pass, values below 0 (down to -1) are low-pass.</p>
</div>
</div>
</div>
<div id="f-sound.effect.onePoleFilter.setParameterModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->onePoleFilter->setParameterModulator(OnePoleFilter* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.onePoleFilter.getParameterModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->onePoleFilter->getParameterModulator(OnePoleFilter* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the filter parameter.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.bitCrusher">BitCrusher</h4>
<div id="f-sound.effect.bitCrusher.newBitCrusher" class="openblock item function">
<div class="title">BitCrusher* playdate->sound->effect->bitCrusher->newBitCrusher(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new BitCrusher effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.bitCrusher.freeBitCrusher" class="openblock item function">
<div class="title">void playdate->sound->effect->bitCrusher->freeBitCrusher(BitCrusher* filter)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.bitCrusher.setAmount" class="openblock item function">
<div class="title">void playdate->sound->effect->bitCrusher->setAmount(BitCrusher* filter, float amount)</div>
<div class="content">
<div class="paragraph">
<p>Sets the amount of crushing to <em>amount</em>. Valid values are 0 (no effect) to 1 (quantizing output to 1-bit).</p>
</div>
</div>
</div>
<div id="f-sound.effect.bitCrusher.setAmountModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->bitCrusher->setAmountModulator(BitCrusher* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.bitCrusher.getAmountModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->bitCrusher->getAmountModulator(BitCrusher* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the crushing amount.</p>
</div>
</div>
</div>
<div id="f-sound.effect.bitCrusher.setUndersampling" class="openblock item function">
<div class="title">void playdate->sound->effect->bitCrusher->setUndersampling(BitCrusher* filter, float undersample)</div>
<div class="content">
<div class="paragraph">
<p>Sets the number of samples to repeat, quantizing the input in time. A value of 0 produces no undersampling, 1 repeats every other sample, etc.</p>
</div>
</div>
</div>
<div id="f-sound.effect.bitCrusher.setUndersampleModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->bitCrusher->setUndersampleModulator(BitCrusher* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.bitCrusher.getUndersampleModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->bitCrusher->getUndersampleModulator(BitCrusher* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the undersampling amount.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.ringModulator">RingModulator</h4>
<div id="f-sound.effect.ringModulator.newRingmod" class="openblock item function">
<div class="title">RingModulator* playdate->sound->effect->ringModulator->newRingmod(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new ring modulator effect.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>[[f-sound.effect.ringModulator.freeRingmod]
.void playdate-&gt;sound-&gt;effect-&gt;ringModulator-&gt;freeRingmod(RingModulator* filter)+*`</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Frees the given effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.ringModulator.setFrequency" class="openblock item function">
<div class="title">void playdate->sound->effect->ringModulator->setFrequency(RingModulator* filter, float frequency)</div>
<div class="content">
<div class="paragraph">
<p>Sets the frequency of the modulation signal.</p>
</div>
</div>
</div>
<div id="f-sound.effect.ringModulator.setFrequencyModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->ringModulator->setFrequencyModulator(RingModulator* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.ringModulator.getFrequencyModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->ringModulator->getFrequencyModulator(RingModulator* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the frequency of the ring modulator.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.overdrive">Overdrive</h4>
<div id="f-sound.effect.overdrive.newOverdrive" class="openblock item function">
<div class="title">Overdrive* playdate->sound->effect->overdrive->newOverdrive(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new overdrive effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.freeOverdrive" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->freeOverdrive(Overdrive* filter)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.setGain" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->setGain(Overdrive* filter, float gain)</div>
<div class="content">
<div class="paragraph">
<p>Sets the gain of the overdrive effect.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.setLimit" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->setLimit(Overdrive* filter, float limit)</div>
<div class="content">
<div class="paragraph">
<p>Sets the level where the amplified input clips.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.setLimitModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->setLimitModulator(Overdrive* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.overdrive.getLimitModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->overdrive->getLimitModulator(RingMoOverdrivedulator* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the limit parameter.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.setOffset" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->setOffset(Overdrive* filter, float offset)</div>
<div class="content">
<div class="paragraph">
<p>Adds an offset to the upper and lower limits to create an asymmetric clipping.</p>
</div>
</div>
</div>
<div id="f-sound.effect.overdrive.setOffsetModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->overdrive->setOffsetModulator(Overdrive* filter, PDSynthSignalValue* signal)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.overdrive.getOffsetModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->overdrive->getOffsetModulator(RingMoOverdrivedulator* filter)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets a <a href="#C-sound.signal">signal</a> to modulate the offset parameter.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.delayLine">DelayLine</h4>
<div id="f-sound.effect.delayLine.newDelayLine" class="openblock item function">
<div class="title">DelayLine* playdate->sound->effect->delayLine->newDelayLine(int length, int stereo)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new delay line effect. The <em>length</em> parameter is given in samples.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.freeDelayLine" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->freeDelayLine(DelayLine* delay)</div>
<div class="content">
<div class="paragraph">
<p>Frees the delay line.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.setLength" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->setLength(DelayLine* d, int frames)</div>
<div class="content">
<div class="paragraph">
<p>Changes the length of the delay line, clearing its contents.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.setFeedback" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->setFeedback(DelayLine* d, float fb)</div>
<div class="content">
<div class="paragraph">
<p>Sets the feedback level of the delay line.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.addTap" class="openblock item function">
<div class="title">DelayLineTap* playdate->sound->effect->delayLine->addTap(DelayLine* d, int delay)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new tap on the delay line, at the given position. <em>delay</em> must be less than or equal to the length of the delay line.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.delayLineTap">DelayLineTap</h4>
<div class="paragraph">
<p>Note that DelayLineTap is a <a href="#C-sound.source">SoundSource</a>, not a <a href="#C-sound.effect">SoundEffect</a>. A delay line tap can be added to any channel, not only the channel the delay line is on.</p>
</div>
<div id="f-sound.effect.delayLine.freeTap" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->freeTap(DelayLineTap* tap)</div>
<div class="content">
<div class="paragraph">
<p>Frees a tap previously created with <a href="#f-sound.effect.delayLine.addTap">playdate&#8594;sound&#8594;delayLine&#8594;addTap()</a>, first removing it from the sound engine if needed.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.setTapDelay" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->setTapDelay(DelayLineTap* tap, int frames)</div>
<div class="content">
<div class="paragraph">
<p>Sets the position of the tap on the delay line, up to the delay line&#8217;s length.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.setTapDelayModulator" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->setTapDelayModulator(DelayLineTap* tap, PDSynthSignalValue* mod)</div>
<div class="content">

</div>
</div>
<div id="f-sound.effect.delayLine.getTapDelayModulator" class="openblock item function">
<div class="title">PDSynthSignalValue* playdate->sound->effect->delayLine->getTapDelayModulator(DelayLineTap* tap)</div>
<div class="content">
<div class="paragraph">
<p>Sets a <a href="#C-sound.signal">signal</a> to modulate the tap delay. If the signal is continuous (e.g. an envelope or a triangle LFO, but not a square LFO) playback is sped up or slowed down to compress or expand time.</p>
</div>
</div>
</div>
<div id="f-sound.effect.delayLine.setTapChannelsFlipped" class="openblock item function">
<div class="title">void playdate->sound->effect->delayLine->setTapChannelsFlipped(DelayLineTap* tap, int flip)</div>
<div class="content">
<div class="paragraph">
<p>If the delay line is stereo and <em>flip</em> is set, the tap outputs the delay line&#8217;s left channel to its right output and vice versa.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.sequence">SoundSequence</h4>
<div id="f-sound.sequence.newSequence" class="openblock item function">
<div class="title">SoundSequence* playdate->sound->sequence->newSequence(void)</div>
<div class="content">

</div>
</div>
<div id="f-sound.sequence.freeSequence" class="openblock item function">
<div class="title">void playdate->sound->sequence->freeSequence(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Creates or destroys a SoundSequence object.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.loadMIDIFile" class="openblock item function">
<div class="title">int playdate->sound->sequence->loadMIDIFile(SoundSequence* sequence, const char* path)</div>
<div class="content">
<div class="paragraph">
<p>If the sequence is empty, attempts to load data from the MIDI file at <em>path</em> into the sequence. Returns 1 on success, 0 on failure.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.play" class="openblock item function">
<div class="title">void playdate->sound->sequence->play(SoundSequence* sequence, SequenceFinishedCallback finishCallback, void* userdata)</div>
<div class="content">

</div>
</div>
<div id="f-sound.sequence.stop" class="openblock item function">
<div class="title">void playdate->sound->sequence->stop(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Starts or stops playing the sequence. <code>finishCallback</code> is an optional function to be called when the sequence finishes playing or is stopped.</p>
</div>
<div id="_SequenceFinishedCallback" class="literalblock">
<div class="title">SequenceFinishedCallback</div>
<div class="content">
<pre>typedef void (*SequenceFinishedCallback)(SoundSequence* seq, void* userdata);</pre>
</div>
</div>
</div>
</div>
<div id="f-sound.sequence.isPlaying" class="openblock item function">
<div class="title">int playdate->sound->sequence->isPlaying(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the sequence is currently playing, otherwise 0.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.getTime" class="openblock item function">
<div class="title">uint32_t playdate->sound->sequence->getTime(SoundSequence* sequence)</div>
<div class="content">

</div>
</div>
<div id="f-sound.sequence.setTime" class="openblock item function">
<div class="title">void playdate->sound->sequence->setTime(SoundSequence* sequence, uint32_t time)</div>
<div class="content">
<div class="paragraph">
<p>Gets or sets the current time in the sequence, in samples since the start of the file. Note that which step this moves the sequence to depends on the current tempo.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.setLoops" class="openblock item function">
<div class="title">void playdate->sound->sequence->setLoops(SoundSequence* sequence, int startstep, int endstep, int loops)</div>
<div class="content">
<div class="paragraph">
<p>Sets the looping range of the sequence. If <em>loops</em> is 0, the loop repeats endlessly.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.getTempo" class="openblock item function">
<div class="title">int playdate->sound->sequence->getTempo(SoundSequence* sequence)</div>
<div class="content">

</div>
</div>
<div id="f-sound.sequence.setTempo" class="openblock item function">
<div class="title">void playdate->sound->sequence->setTempo(SoundSequence* sequence, int stepsPerSecond)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets the tempo of the sequence, in steps per second.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.getLength" class="openblock item function">
<div class="title">int playdate->sound->sequence->getLength(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Returns the length of the longest track in the sequence. See also <a href="#m-sound.track:getLength">playdate.sound.track.getLength()</a>.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.getTrackCount" class="openblock item function">
<div class="title">int playdate->sound->sequence->getTrackCount(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of tracks in the sequence.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.addTrack" class="openblock item function">
<div class="title">SequenceTrack* playdate->sound->sequence->addTrack(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Adds the given <a href="#C-sound.track">playdate.sound.track</a> to the sequence.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.getTrackAtIndex" class="openblock item function">
<div class="title">SequenceTrack* playdate->sound->sequence->getTrackAtIndex(SoundSequence* sequence, unsigned int idx)</div>
<div class="content">

</div>
</div>
<div id="f-sound.sequence.setTrackAtIndex" class="openblock item function">
<div class="title">void playdate->sound->sequence->setTrackAtIndex(SoundSequence* sequence, SequenceTrack* track, unsigned int idx)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets the given <a href="#C-sound.track">SoundTrack</a> object at position <em>idx</em> in the sequence.</p>
</div>
</div>
</div>
<div id="f-sound.sequence.allNotesOff" class="openblock item function">
<div class="title">void playdate->sound->sequence->allNotesOff(SoundSequence* sequence)</div>
<div class="content">
<div class="paragraph">
<p>Sends a stop signal to all playing notes on all tracks.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.ControlSignal">ControlSignal</h4>
<div class="paragraph">
<p><em>ControlSignal</em> is a subclass of <a href="#C-sound.PDSynthSignal">PDSynthSignal</a> used for sequencing changes to parameters.</p>
</div>
<div id="f-sound.controlsignal.newSignal" class="openblock item function">
<div class="title">ControlSignal* playdate->sound->controlsignal->newSignal(void)</div>
<div class="content">
<div class="paragraph">
<p>Creates a new control signal object.</p>
</div>
</div>
</div>
<div id="f-sound.controlsignal.freeSignal" class="openblock item function">
<div class="title">void playdate->sound->controlsignal->freeSignal(ControlSignal* signal)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given signal.</p>
</div>
</div>
</div>
<div id="f-sound.controlsignal.clearEvents" class="openblock item function">
<div class="title">void playdate->sound->controlsignal->clearEvents(ControlSignal* signal)</div>
<div class="content">
<div class="paragraph">
<p>Clears all events from the given signal.</p>
</div>
</div>
</div>
<div id="f-sound.controlsignal.addEvent" class="openblock item function">
<div class="title">void playdate->sound->controlsignal->addEvent(ControlSignal* signal, int step, float value, int interpolate)</div>
<div class="content">
<div class="paragraph">
<p>Adds a value to the signal&#8217;s timeline at the given step. If <em>interpolate</em> is set, the value is interpolated between the previous step+value and this one.</p>
</div>
</div>
</div>
<div id="f-sound.controlsignal.removeEvent" class="openblock item function">
<div class="title">void playdate->sound->controlsignal->removeEvent(ControlSignal* signal, int step)</div>
<div class="content">
<div class="paragraph">
<p>Removes the control event at the given step.</p>
</div>
</div>
</div>
<div id="f-sound.controlsignal.getMIDIControllerNumber" class="openblock item function">
<div class="title">int playdate->sound->controlsignal->getMIDIControllerNumber(ControlSignal* signal)</div>
<div class="content">
<div class="paragraph">
<p>Returns the MIDI controller number for this ControlSignal, if it was created from a MIDI file via <a href="#f-sound.sequence.loadMIDIFile">playdate&#8594;sound&#8594;sequence&#8594;loadMIDIFile()</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="C-sound.SequenceTrack">SequenceTrack</h4>
<div class="paragraph">
<p>A <em>SequenceTrack</em> comprises a <a href="#C-sound.PDSynthInstrument">PDSynthInstrument</a>, a sequence of notes to play on that instrument, and any number of <a href="#C-sound.ControlSignal">ControlSignal</a> objects to control parameter changes.</p>
</div>
<div id="f-sound.track.newTrack" class="openblock item function">
<div class="title">SequenceTrack* playdate->sound->track->newTrack(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns a new SequenceTrack.</p>
</div>
</div>
</div>
<div id="f-sound.track.freeTrack" class="openblock item function">
<div class="title">void playdate->sound->track->freeTrack(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Frees the SequenceTrack.</p>
</div>
</div>
</div>
<div id="f-sound.track.setInstrument" class="openblock item function">
<div class="title">void playdate->sound->track->setInstrument(SequenceTrack* track, PDSynthInstrument* instrument)</div>
<div class="content">

</div>
</div>
<div id="f-sound.track.getInstrument" class="openblock item function">
<div class="title">PDSynthInstrument* playdate->sound->track->getInstrument(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Sets or gets the <a href="#C-sound.PDSynthInstrument">PDSynthInstrument</a> assigned to the track.</p>
</div>
</div>
</div>
<div id="f-sound.track.addNoteEvent" class="openblock item function">
<div class="title">void playdate->sound->track->addNoteEvent(SequenceTrack* track, uint32_t step, uint32_t length, MIDINote note, float vel)</div>
<div class="content">
<div class="paragraph">
<p>Adds a single note event to the track.</p>
</div>
</div>
</div>
<div id="f-sound.track.removeNoteEvent" class="openblock item function">
<div class="title">void playdate->sound->track->removeNoteEvent(SequenceTrack* track, uint32_t step, MIDINote note)</div>
<div class="content">
<div class="paragraph">
<p>Removes the event at <em>step</em> playing <em>note</em>.</p>
</div>
</div>
</div>
<div id="f-sound.track.clearNotes" class="openblock item function">
<div class="title">void playdate->sound->track->clearNotes(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Clears all notes from the track.</p>
</div>
</div>
</div>
<div id="f-sound.track.getLength" class="openblock item function">
<div class="title">int playdate->sound->track->getLength(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Returns the length, in steps, of the track&#8212;&#8203;that is, the step where the last note in the track ends.</p>
</div>
</div>
</div>
<div id="f-sound.track.getIndexForStep" class="openblock item function">
<div class="title">int playdate->sound->track->getIndexForStep(SequenceTrack* track, uint32_t step)</div>
<div class="content">
<div class="paragraph">
<p>Returns the internal array index for the first note at the given step.</p>
</div>
</div>
</div>
<div id="f-sound.track.getNoteAtIndex" class="openblock item function">
<div class="title">int playdate->sound->track->getNoteAtIndex(SequenceTrack* track, int index, uint32_t* outStep, uint32_t* outLen, MIDINote* outNote, float* outVelocity)</div>
<div class="content">
<div class="paragraph">
<p>If the given index is in range, sets the data in the out pointers and returns 1; otherwise, returns 0.</p>
</div>
</div>
</div>
<div id="f-sound.track.getControlSignalCount" class="openblock item function">
<div class="title">void playdate->sound->track->getControlSignalCount(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of <a href="#C-sound.ControlSignal">ControlSignal</a> objects in the track.</p>
</div>
</div>
</div>
<div id="f-sound.track.getControlSignal" class="openblock item function">
<div class="title">void playdate->sound->track->getControlSignal(SequenceTrack* track, int idx)</div>
<div class="content">
<div class="paragraph">
<p>Returns the <a href="#C-sound.ControlSignal">ControlSignal</a> at index <em>idx</em>.</p>
</div>
</div>
</div>
<div id="f-sound.track.getSignalForController" class="openblock item function">
<div class="title">void playdate->sound->track->getSignalForController(SequenceTrack* track, int controller, int create)</div>
<div class="content">
<div class="paragraph">
<p>Returns the <a href="#C-sound.ControlSignal">ControlSignal</a> for MIDI controller number <em>controller</em>, creating it if the <strong>create</strong> flag is set and it doesn&#8217;t yet exist.</p>
</div>
</div>
</div>
<div id="f-sound.track.clearControlEvents" class="openblock item function">
<div class="title">void playdate->sound->track->clearControlEvents(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Clears all <a href="#C-sound.ControlSignal">ControlSignals</a> from the track.</p>
</div>
</div>
</div>
<div id="f-sound.track.activeVoiceCount" class="openblock item function">
<div class="title">int playdate->sound->track->activeVoiceCount(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of voices currently playing in the track&#8217;s instrument.</p>
</div>
</div>
</div>
<div id="f-sound.track.getPolyphony" class="openblock item function">
<div class="title">int playdate->sound->track->getPolyphony(SequenceTrack* track)</div>
<div class="content">
<div class="paragraph">
<p>Returns the maximum number of simultaneously playing notes in the track. (Currently, this value is only set when the track was loaded from a MIDI file. We don&#8217;t yet track polyphony for user-created events.)</p>
</div>
</div>
</div>
<div id="f-sound.track.setMuted" class="openblock item function">
<div class="title">void playdate->sound->track->setMuted(SequenceTrack* track, int mute)</div>
<div class="content">
<div class="paragraph">
<p>Mutes or unmutes the track.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_display">5.3. Display</h3>
<div id="f-display.getHeight" class="openblock item function xref">
<div class="title">int playdate->display->getHeight(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the height of the display, taking the current scale into account; e.g., if the scale is 2, this function returns 120 instead of 240.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.getHeight"><code>playdate.display.getHeight()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.getWidth" class="openblock item function xref">
<div class="title">int playdate->display->getWidth(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the width of the display, taking the current scale into account; e.g., if the scale is 2, this function returns 200 instead of 400.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.getWidth"><code>playdate.display.getWidth()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setInverted" class="openblock item function xref">
<div class="title">void playdate->display->setInverted(int flag)</div>
<div class="content">
<div class="paragraph">
<p>If <em>flag</em> evaluates to true, the frame buffer is drawn inverted—black instead of white, and vice versa.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setInverted"><code>playdate.display.setInverted()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setMosaic" class="openblock item function xref">
<div class="title">void playdate->display->setMosaic(unsigned int x, unsigned int y)</div>
<div class="content">
<div class="paragraph">
<p>Adds a mosaic effect to the display. Valid <em>x</em> and <em>y</em> values are between 0 and 3, inclusive.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setMosaic"><code>playdate.display.setMosaic</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setFlipped" class="openblock item function xref">
<div class="title">void playdate->display->setFlipped(int x, int y)</div>
<div class="content">
<div class="paragraph">
<p>Flips the display on the x or y axis, or both.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setFlipped"><code>playdate.display.setFlipped()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setRefreshRate" class="openblock item function xref">
<div class="title">void playdate->display->setRefreshRate(float rate)</div>
<div class="content">
<div class="paragraph">
<p>Sets the nominal refresh rate in frames per second. Default is 20 fps, the maximum rate supported by the hardware for full-frame updates.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setRefreshRate"><code>playdate.display.setRefreshRate()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setScale" class="openblock item function xref">
<div class="title">void playdate->display->setScale(unsigned int s)</div>
<div class="content">
<div class="paragraph">
<p>Sets the display scale factor. Valid values for <em>scale</em> are 1, 2, 4, and 8.</p>
</div>
<div class="paragraph">
<p>The top-left corner of the frame buffer is scaled up to fill the display; e.g., if the scale is set to 4, the pixels in rectangle [0,100] x [0,60] are drawn on the screen as 4 x 4 squares.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setScale"><code>playdate.display.setScale()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-display.setOffset" class="openblock item function xref">
<div class="title">void playdate->display->setOffset(int dx, int dy)</div>
<div class="content">
<div class="paragraph">
<p>Offsets the display by the given amount. Areas outside of the displayed area are filled with the current <a href="#f-graphics.setBackgroundColor">background color</a>.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-display.setOffset"><code>playdate.display.setOffset()</code></a> in the Lua API.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filesystem">5.4. Filesystem</h3>
<div id="f-file.geterr" class="openblock item function">
<div class="title">const char* playdate->file->geterr(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns human-readable text describing the most recent error (usually indicated by a -1 return from a filesystem function).</p>
</div>
</div>
</div>
<div id="f-file.listfiles" class="openblock item function xref">
<div class="title">int playdate->file->listfiles(const char* path, void (*callback)(const char* filename, void* userdata), void* userdata, int showhidden);</div>
<div class="content">
<div class="paragraph">
<p>Calls the given callback function for every file at <em>path</em>. Subfolders are indicated by a trailing slash '/' in <em>filename</em>. <em>listfiles()</em> does not recurse into subfolders. If <em>showhidden</em> is set, files beginning with a period will be included; otherwise, they are skipped. Returns 0 on success, -1 if no folder exists at <em>path</em> or it can&#8217;t be opened.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.listFiles"><code>playdate.file.listFiles()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.unlink" class="openblock item function">
<div class="title">int playdate->file->unlink(const char* path, int recursive);</div>
<div class="content">
<div class="paragraph">
<p>Deletes the file at <em>path</em>. Returns 0 on success, or -1 in case of error. If recursive is 1 and the target path is a folder, this deletes everything inside the folder (including folders, folders inside those, and so on) as well as the folder itself.</p>
</div>
</div>
</div>
<div id="f-file.mkdir" class="openblock item function xref">
<div class="title">int playdate->file->mkdir(const char* path);</div>
<div class="content">
<div class="paragraph">
<p>Creates the given <em>path</em> in the Data/&lt;gameid&gt; folder. It does not create intermediate folders. Returns 0 on success, or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.mkdir"><code>playdate.file.mkdir()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.rename" class="openblock item function xref">
<div class="title">int playdate->file->rename(const char* from, const char* to);</div>
<div class="content">
<div class="paragraph">
<p>Renames the file at <em>from</em> to <em>to</em>. It will overwrite the file at <em>to</em> without confirmation. It does not create intermediate folders. Returns 0 on success, or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.rename"><code>playdate.file.rename()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.stat" class="openblock item function">
<div class="title">int playdate->file->stat(const char* path, FileStat* stat);</div>
<div class="content">
<div class="paragraph">
<p>Populates the FileStat <em>stat</em> with information about the file at <em>path</em>. Returns 0 on success, or -1 in case of error.</p>
</div>
<div class="literalblock">
<div class="title">FileStat</div>
<div class="content">
<pre>typedef struct
{
	int isdir;
	unsigned int size;
	int m_year;
	int m_month;
	int m_day;
	int m_hour;
	int m_minute;
	int m_second;
} FileStat;</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_files">Files</h4>
<div id="f-file.close" class="openblock item function xref">
<div class="title">int playdate->file->close(SDFile* file);</div>
<div class="content">
<div class="paragraph">
<p>Closes the given <em>file</em> handle. Returns 0 on success, or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.close"><code>playdate.file.close()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.flush" class="openblock item function xref">
<div class="title">int playdate->file->flush(SDFile* file);</div>
<div class="content">
<div class="paragraph">
<p>Flushes the output buffer of <em>file</em> immediately. Returns the number of bytes written, or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.flush"><code>playdate.file.flush()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.open" class="openblock item function xref">
<div class="title">SDFile* playdate->file->open(const char* path, FileOptions mode);</div>
<div class="content">
<div class="paragraph">
<p>Opens a handle for the file at <em>path</em>. The <em>kFileRead</em> mode opens a file in the game pdx, while <em>kFileReadData</em> searches the game&#8217;s data folder; to search the data folder first then fall back on the game pdx, use the bitwise combination <em>kFileRead|kFileReadData</em>.<em>kFileWrite</em> and <em>kFileAppend</em> always write to the data folder. The function returns NULL if a file at <em>path</em> cannot be opened, and <a href="#f-file.geterr">playdate->file->geterr()</a> will describe the error. The filesystem has a limit of 64 simultaneous open files.</p>
</div>
<div class="literalblock">
<div class="title">FileOptions</div>
<div class="content">
<pre>typedef enum
{
	kFileRead,
	kFileReadData,
	kFileWrite,
	kFileAppend
} FileOptions;</pre>
</div>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-file.open"><code>playdate.file.open()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.read" class="openblock item function xref">
<div class="title">int playdate->file->read(SDFile* file, void* buf, unsigned int len);</div>
<div class="content">
<div class="paragraph">
<p>Reads up to <em>len</em> bytes from the <em>file</em> into the buffer <em>buf</em>. Returns the number of bytes read (0 indicating end of file), or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-file.read"><code>playdate.file.file:read()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.seek" class="openblock item function xref">
<div class="title">int playdate->file->seek(SDFile* file, int pos, int whence);</div>
<div class="content">
<div class="paragraph">
<p>Sets the read/write offset in the given <em>file</em> handle to <em>pos</em>, relative to the <em>whence</em> macro. SEEK_SET is relative to the beginning of the file, SEEK_CUR is relative to the current position of the file pointer, and SEEK_END is relative to the end of the file. Returns 0 on success, -1 on error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-file.seek"><code>playdate.file.file:seek()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.tell" class="openblock item function xref">
<div class="title">int playdate->file->tell(SDFile* file);</div>
<div class="content">
<div class="paragraph">
<p>Returns the current read/write offset in the given <em>file</em> handle, or -1 on error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-file.tell"><code>playdate.file.file:tell()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-file.write" class="openblock item function xref">
<div class="title">int playdate->file->write(SDFile* file, const void* buf, unsigned int len);</div>
<div class="content">
<div class="paragraph">
<p>Writes the buffer of bytes <em>buf</em> to the <em>file</em>. Returns the number of bytes written, or -1 in case of error.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-file.write"><code>playdate.file.file:write()</code></a> in the Lua API.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_graphics">5.5. Graphics</h3>
<div class="paragraph">
<p>The drawing functions use a context stack to select the drawing target, for setting a stencil, changing the draw mode, etc. The stack is unwound at the beginning of each update cycle, with drawing restored to target the display.</p>
</div>
<div id="f-graphics.pushContext" class="openblock item function xref">
<div class="title">void playdate->graphics->pushContext(LCDBitmap* target);</div>
<div class="content">
<div class="paragraph">
<p>Push a new drawing context for drawing into the given bitmap. If <em>target</em> is nil, the drawing functions will use the display framebuffer.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.pushContext"><code>playdate.graphics.pushContext()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.popContext" class="openblock item function xref">
<div class="title">void playdate->graphics->popContext(void);</div>
<div class="content">
<div class="paragraph">
<p>Pops a context off the stack (if any are left), restoring the drawing settings from before the context was pushed.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.popContext"><code>playdate.graphics.popContext()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setStencil" class="openblock item function">
<div class="title">void playdate->graphics->setStencil(LCDBitmap* stencil);</div>
<div class="content">
<div class="paragraph">
<p>Sets the stencil used for drawing. For a tiled stencil, use <em>setStencilImage()</em> instead.</p>
</div>
</div>
</div>
<div id="f-graphics.setStencilImage" class="openblock item function xref">
<div class="title">void playdate->graphics->setStencilImage(LCDBitmap* stencil, int tile);</div>
<div class="content">
<div class="paragraph">
<p>Sets the stencil used for drawing. If the <em>tile</em> flag is set the stencil image will be tiled. Tiled stencils must have width equal to a multiple of 32 pixels.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setStencilImage"><code>playdate.graphics.setStencilImage()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setDrawMode" class="openblock item function">
<div class="title">void playdate->graphics->setDrawMode(LCDBitmapDrawMode mode);</div>
<div class="content">
<div class="paragraph">
<p>Sets the mode used for drawing bitmaps. Note that text drawing uses bitmaps, so this affects how fonts are displayed as well.</p>
</div>
<div class="literalblock">
<div class="title">LCDBitmapDrawMode</div>
<div class="content">
<pre>typedef enum
{
	kDrawModeCopy,
	kDrawModeWhiteTransparent,
	kDrawModeBlackTransparent,
	kDrawModeFillWhite,
	kDrawModeFillBlack,
	kDrawModeXOR,
	kDrawModeNXOR,
	kDrawModeInverted
} LCDBitmapDrawMode;</pre>
</div>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setImageDrawMode"><code>playdate.graphics.setImageDrawMode()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setClipRect" class="openblock item function xref">
<div class="title">void playdate->graphics->setClipRect(int x, int y, int width, int height);</div>
<div class="content">
<div class="paragraph">
<p>Sets the current clip rect, using world coordinates&#8212;&#8203;that is, the given rectangle will be translated by the current drawing offset. The clip rect is cleared at the beginning of each update.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setClipRect"><code>playdate.graphics.setClipRect()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setScreenClipRect" class="openblock item function xref">
<div class="title">void playdate->graphics->setScreenClipRect(int x, int y, int width, int height);</div>
<div class="content">
<div class="paragraph">
<p>Sets the current clip rect in screen coordinates.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setScreenClipRect"><code>playdate.graphics.setScreenClipRect()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.clearClipRect" class="openblock item function xref">
<div class="title">void playdate->graphics->clearClipRect(void);</div>
<div class="content">
<div class="paragraph">
<p>Clears the current clip rect.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.clearClipRect"><code>playdate.graphics.clearClipRect()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setLineCapStyle" class="openblock item function xref">
<div class="title">void playdate->graphics->setLineCapStyle(LCDLineCapStyle endCapStyle);</div>
<div class="content">
<div class="paragraph">
<p>Sets the end cap style used in the line drawing functions.</p>
</div>
<div class="literalblock">
<div class="title">LCDLineCapStyle</div>
<div class="content">
<pre>typedef enum
{
	kLineCapStyleButt,
	kLineCapStyleSquare,
	kLineCapStyleRound
} LCDLineCapStyle;</pre>
</div>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setLineCapStyle"><code>playdate.graphics.setLineCapStyle()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setFont" class="openblock item function xref">
<div class="title">void playdate->graphics->setFont(LCDFont* font);</div>
<div class="content">
<div class="paragraph">
<p>Sets the font to use in subsequent <a href="#f-graphics.drawText">drawText</a> calls.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setFont"><code>playdate.graphics.setFont()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setTextTracking" class="openblock item function xref">
<div class="title">void playdate->graphics->setTextTracking(int tracking);</div>
<div class="content">
<div class="paragraph">
<p>Sets the tracking to use when drawing text.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-graphics.font.setTracking"><code>playdate.graphics.font:setTracking()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setTextLeading" class="openblock item function xref">
<div class="title">void playdate->graphics->setTextLeading(int leading);</div>
<div class="content">
<div class="paragraph">
<p>Sets the leading adjustment (added to the leading specified in the font) to use when drawing text.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#m-graphics.font.setLeading"><code>playdate.graphics.font:setLeading()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_supporting_types">Supporting types</h4>
<div id="_LCDColor_" class="literalblock">
<div class="title">LCDColor</div>
<div class="content">
<pre>Either an LCDSolidColor or an LCDPattern*.</pre>
</div>
</div>
<div class="literalblock">
<div class="title">LCDSolidColor</div>
<div class="content">
<pre>typedef enum
{
	kColorBlack,
	kColorWhite,
	kColorClear,
	kColorXOR
} LCDSolidColor;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">LCDPattern</div>
<div class="content">
<pre>typedef uint8_t LCDPattern[16];</pre>
</div>
</div>
<div id="_LCDBitmapFlip" class="literalblock">
<div class="title">LCDBitmapFlip</div>
<div class="content">
<pre>typedef enum
{
	kBitmapUnflipped,
	kBitmapFlippedX,
	kBitmapFlippedY,
	kBitmapFlippedXY
} LCDBitmapFlip;</pre>
</div>
</div>
<div id="_LCDRect" class="literalblock">
<div class="title">LCDRect</div>
<div class="content">
<pre>typedef struct
{
	int left;
	int right;
	int top;
	int bottom;
} LCDRect;</pre>
</div>
</div>
<div id="_PDRect" class="literalblock">
<div class="title">PDRect</div>
<div class="content">
<pre>typedef struct
{
	float x;
	float y;
	float width;
	float height;
} PDRect;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bitmaps">Bitmaps</h4>
<div id="f-graphics.clearBitmap" class="openblock item function">
<div class="title">void playdate->graphics->clearBitmap(LCDBitmap* bitmap, LCDColor bgcolor);</div>
<div class="content">
<div class="paragraph">
<p>Clears <em>bitmap</em>, filling with the given <em>bgcolor</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.copyBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->copyBitmap(LCDBitmap* bitmap);</div>
<div class="content">
<div class="paragraph">
<p>Returns a new LCDBitmap that is an exact copy of <em>bitmap</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.checkMaskCollision" class="openblock item function">
<div class="title">int playdate->graphics->checkMaskCollision(LCDBitmap* bitmap1, int x1, int y1, LCDBitmapFlip flip1, LCDBitmap* bitmap2, int x2, int y2, LCDBitmapFlip flip2, LCDRect rect);</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if any of the opaque pixels in <em>bitmap1</em> when positioned at <em>x1</em>, <em>y1</em> with <em>flip1</em> overlap any of the opaque pixels in <em>bitmap2</em> at <em>x2</em>, <em>y2</em> with <em>flip2</em> within the non-empty <em>rect</em>, or 0 if no pixels overlap or if one or both fall completely outside of <em>rect</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.drawBitmap" class="openblock item function">
<div class="title">void playdate->graphics->drawBitmap(LCDBitmap* bitmap, int x, int y, LCDBitmapFlip flip);</div>
<div class="content">
<div class="paragraph">
<p>Draws the <em>bitmap</em> with its upper-left corner at location <em>x</em>, <em>y</em>, using the given flip orientation.</p>
</div>
</div>
</div>
<div id="f-graphics.drawScaledBitmap" class="openblock item function">
<div class="title">void playdate->graphics->drawScaledBitmap(LCDBitmap* bitmap, int x, int y, float xscale, float yscale);</div>
<div class="content">
<div class="paragraph">
<p>Draws the <em>bitmap</em> scaled to <em>xscale</em> and <em>yscale</em> with its upper-left corner at location <em>x</em>, <em>y</em>. Note that <em>flip</em> is not available when drawing scaled bitmaps but negative scale values will achieve the same effect.</p>
</div>
</div>
</div>
<div id="f-graphics.drawRotatedBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->drawRotatedBitmap(LCDBitmap* bitmap, int x, int y, float degrees, float centerx, float centery, float xscale, float yscale);</div>
<div class="content">
<div class="paragraph">
<p>Draws the <em>bitmap</em> scaled to <em>xscale</em> and <em>yscale</em> then rotated by <em>degrees</em> with its center as given by proportions <em>centerx</em> and <em>centery</em> at <em>x</em>, <em>y</em>; that is: if <em>centerx</em> and <em>centery</em> are both 0.5 the center of the image is at (<em>x</em>,<em>y</em>), if <em>centerx</em> and <em>centery</em> are both 0 the top left corner of the image (before rotation) is at (<em>x</em>,<em>y</em>), etc.</p>
</div>
</div>
</div>
<div id="f-graphics.freeBitmap" class="openblock item function">
<div class="title">void playdate->graphics->freeBitmap(LCDBitmap*);</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>bitmap</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.getBitmapData" class="openblock item function">
<div class="title">void playdate->graphics->getBitmapData(LCDBitmap* bitmap, int* width, int* height, int* rowbytes, uint8_t** mask, uint8_t** data);</div>
<div class="content">
<div class="paragraph">
<p>Gets various info about <em>bitmap</em> including its <em>width</em> and <em>height</em> and raw pixel data. The data is 1 bit per pixel packed format, in MSB order; in other words, the high bit of the first byte in <code>data</code> is the top left pixel of the image. If the bitmap has a mask, a pointer to its data is returned in <em>mask</em>, else NULL is returned.</p>
</div>
</div>
</div>
<div id="f-graphics.loadBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->loadBitmap(const char* path, const char** outerr);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new LCDBitmap from the file at <em>path</em>. If there is no file at <em>path</em>, the function returns null.</p>
</div>
</div>
</div>
<div id="f-graphics.loadIntoBitmap" class="openblock item function">
<div class="title">void playdate->graphics->loadIntoBitmap(const char* path, LCDBitmap* bitmap, const char** outerr);</div>
<div class="content">
<div class="paragraph">
<p>Loads the image at <em>path</em> into the previously allocated <em>bitmap</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.newBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->newBitmap(int width, int height, LCDColor bgcolor);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new <em>width</em> by <em>height</em> LCDBitmap filled with <em>bgcolor</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.tileBitmap" class="openblock item function">
<div class="title">void playdate->graphics->tileBitmap(LCDBitmap* bitmap, int x, int y, int width, int height, LCDBitmapFlip flip);</div>
<div class="content">
<div class="paragraph">
<p>Draws the <em>bitmap</em> with its upper-left corner at location <em>x</em>, <em>y</em> tiled inside a <em>width</em> by <em>height</em> rectangle.</p>
</div>
</div>
</div>
<div id="f-graphics.rotatedBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->rotatedBitmap(LCDBitmap* bitmap, float rotation, float xscale, float yscale, int* allocedSize);</div>
<div class="content">
<div class="paragraph">
<p>Returns a new, rotated and scaled LCDBitmap based on the given <em>bitmap</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.setBitmapMask" class="openblock item function">
<div class="title">int playdate->graphics->setBitmapMask(LCDBitmap* bitmap, LCDBitmap* mask);</div>
<div class="content">
<div class="paragraph">
<p>Sets a mask image for the given <em>bitmap</em>. The set mask must be the same size as the target bitmap.</p>
</div>
</div>
</div>
<div id="f-graphics.getBitmapMask" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->getBitmapMask(LCDBitmap* bitmap);</div>
<div class="content">
<div class="paragraph">
<p>Gets a mask image for the given <em>bitmap</em>. If the image doesn&#8217;t have a mask, <em>getBitmapMask</em> returns NULL.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bitmaptables">BitmapTables</h4>
<div id="f-graphics.getTableBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->getTableBitmap(LCDBitmapTable* table, int idx);</div>
<div class="content">
<div class="paragraph">
<p>Returns the <em>idx</em> bitmap in <em>table</em>, If <em>idx</em> is out of bounds, the function returns NULL.</p>
</div>
</div>
</div>
<div id="f-graphics.loadBitmapTable" class="openblock item function">
<div class="title">LCDBitmapTable* playdate->graphics->loadBitmapTable(const char* path, const char** outerr);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new LCDBitmap from the file at <em>path</em>. If there is no file at <em>path</em>, the function returns null.</p>
</div>
</div>
</div>
<div id="f-graphics.loadIntoBitmapTable" class="openblock item function">
<div class="title">void playdate->graphics->loadIntoBitmapTable(const char* path, LCDBitmapTable* table, const char** outerr);</div>
<div class="content">
<div class="paragraph">
<p>Loads the imagetable at <em>path</em> into the previously allocated <em>table</em>.</p>
</div>
</div>
</div>
<div id="f-graphics.newBitmapTable" class="openblock item function">
<div class="title">LCDBitmapTable* playdate->graphics->newBitmapTable(int count, int width, int height);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new LCDBitmapTable that can hold <em>count</em> <em>width</em> by <em>height</em> LCDBitmaps.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fonts_text">Fonts &amp; Text</h4>
<div id="f-graphics.drawText" class="openblock item function xref">
<div class="title">int playdate->graphics->drawText(const void* text, size_t len, PDStringEncoding encoding, int x, int y);</div>
<div class="content">
<div class="paragraph">
<p>Draws the given text using the provided options. If no font has been set with <a href="#f-graphics.setFont">setFont</a>, the default system font Asheville Sans 14 Light is used.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.drawText"><code>playdate.graphics.drawText()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.getFontHeight" class="openblock item function">
<div class="title">uint8_t playdate->graphics->getFontHeight(LCDFont* font);</div>
<div class="content">
<div class="paragraph">
<p>Returns the height of the given font.</p>
</div>
</div>
</div>
<div id="f-graphics.getFontPage" class="openblock item function">
<div class="title">LCDFontPage* playdate->graphics->getFontPage(LCDFont* font, uint32_t c);</div>
<div class="content">
<div class="paragraph">
<p>Returns an LCDFontPage object for the given character code. Each LCDFontPage contains information for 256 characters; specifically, if <code>(c1 &amp; ~0xff) == (c2 &amp; ~0xff)</code>, then <em>c1</em> and <em>c2</em> belong to the same page and the same LCDFontPage can be used to fetch the character data for both instead of searching for the page twice.</p>
</div>
</div>
</div>
<div id="f-graphics.getPageGlyph" class="openblock item function">
<div class="title">LCDFontGlyph* getPageGlyph(LCDFontPage* page, uint32_t c, LCDBitmap** bitmap, int* advance);</div>
<div class="content">
<div class="paragraph">
<p>Returns an LCDFontGlyph object for character <em>c</em> in LCDFontPage <em>page</em>, and optionally returns the glyph&#8217;s bitmap and advance value.</p>
</div>
</div>
</div>
<div id="f-graphics.getGlyphKerning" class="openblock item function">
<div class="title">int (*getGlyphKerning)(LCDFontGlyph* glyph, uint32_t c1, uint32_t c2);</div>
<div class="content">
<div class="paragraph">
<p>Returns the kerning adjustment between characters <em>c1</em> and <em>c2</em> as specified by the font.</p>
</div>
</div>
</div>
<div id="f-graphics.getTextWidth" class="openblock item function">
<div class="title">int playdate->graphics->getTextWidth(LCDFont* font, const void* text, size_t len, PDStringEncoding encoding, int tracking);</div>
<div class="content">
<div class="paragraph">
<p>Returns the width of the given text in the given font.</p>
</div>
<div class="literalblock">
<div class="title">PDStringEncoding</div>
<div class="content">
<pre>typedef enum
{
	kASCIIEncoding,
	kUTF8Encoding,
	k16BitLEEncoding
} PDStringEncoding;</pre>
</div>
</div>
</div>
</div>
<div id="f-graphics.loadFont" class="openblock item function">
<div class="title">LCDFont* playdate->graphics->loadFont(const char* path, const char** outErr);</div>
<div class="content">
<div class="paragraph">
<p>Returns the LCDFont object for the font file at <em>path</em>. In case of error, <em>outErr</em> points to a string describing the error.</p>
</div>
</div>
</div>
<div id="f-graphics.makeFontFromData" class="openblock item function">
<div class="title">LCDFont* playdate->graphics->makeFontFromData(LCDFontData* data, int wide);</div>
<div class="content">
<div class="paragraph">
<p>Returns an LCDFont object wrapping the LCDFontData <em>data</em> comprising the contents (minus 16-byte header) of an uncompressed pft file. <em>wide</em> corresponds to the flag in the header indicating whether the font contains glyphs at codepoints above U+1FFFF.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_geometry">Geometry</h4>
<div id="f-graphics.drawEllipse" class="openblock item function">
<div class="title">void playdate->graphics->drawEllipse(int x, int y, int width, int height, int lineWidth, float startAngle, float endAngle, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Draws an ellipse inside the rectangle {x, y, width, height} of width <em>lineWidth</em> (inset from the rectangle bounds). If <em>startAngle</em> != _endAngle, this draws an arc between the given angles. Angles are given in degrees, clockwise from due north.</p>
</div>
</div>
</div>
<div id="f-graphics.fillEllipse" class="openblock item function">
<div class="title">void playdate->graphics->fillEllipse(int x, int y, int width, int height, float startAngle, float endAngle, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Fills an ellipse inside the rectangle {x, y, width, height}. If <em>startAngle</em> != _endAngle, this draws a wedge/Pacman between the given angles. Angles are given in degrees, clockwise from due north.</p>
</div>
</div>
</div>
<div id="f-graphics.drawLine" class="openblock item function xref">
<div class="title">void playdate->graphics->drawLine(int x1, int y1, int x2, int y2, int width, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Draws a line from <em>x1</em>, <em>y1</em> to <em>x2</em>, <em>y2</em> with a stroke width of <em>width</em>.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.drawLine"><code>playdate.graphics.drawLine()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.drawRect" class="openblock item function xref">
<div class="title">void playdate->graphics->drawRect(int x, int y, int width, int height, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Draws a <em>width</em> by <em>height</em> rect at <em>x</em>, <em>y</em>.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.drawRect"><code>playdate.graphics.drawRect()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.fillRect" class="openblock item function xref">
<div class="title">void playdate->graphics->fillRect(int x, int y, int width, int height, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Draws a filled <em>width</em> by <em>height</em> rect at <em>x</em>, <em>y</em>.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.fillRect"><code>playdate.graphics.fillRect()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.fillTriangle" class="openblock item function xref">
<div class="title">void playdate->graphics->fillTriangle(int x1, int y1, int x2, int y2, int x3, int y3, LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Draws a filled triangle with points at <em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, and <em>x3</em>, <em>y3</em>.</p>
</div>
<div class="literalblock">
<div class="title">LCDWindingRule</div>
<div class="content">
<pre>typedef enum
{
	kPolygonFillNonZero,
	kPolygonFillEvenOdd
} LCDPolygonFillRule;</pre>
</div>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.fillTriangle"><code>playdate.graphics.fillTriangle()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.fillPolygon" class="openblock item function xref">
<div class="title">void playdate->graphics->fillPolygon(int nPoints, int* points, LCDColor color, LCDPolygonFillRule fillrule);</div>
<div class="content">
<div class="paragraph">
<p>Fills the polygon with vertices at the given coordinates (an array of 2*<code>nPoints</code> ints containing alternating x and y values) using the given color and fill, or winding, rule. See <a href="https://en.wikipedia.org/wiki/Nonzero-rule" class="bare">https://en.wikipedia.org/wiki/Nonzero-rule</a> for an explanation of the winding rule.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.fillPolygon"><code>playdate.graphics.fillPolygon()</code></a> in the Lua API.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_miscellaneous_2">Miscellaneous</h4>
<div id="f-graphics.clear" class="openblock item function xref">
<div class="title">void playdate->graphics->clear(LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Clears the entire display, filling it with <em>color</em>.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.clear"><code>playdate.graphics.clear()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setBackgroundColor" class="openblock item function xref">
<div class="title">void playdate->graphics->setBackgroundColor(LCDColor color);</div>
<div class="content">
<div class="paragraph">
<p>Sets the background color shown when the display is <a href="#f-display.setOffset">offset</a> or for clearing dirty areas in the sprite system.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setBackgroundColor"><code>playdate.graphics.setBackgroundColor()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.display" class="openblock item function">
<div class="title">void playdate->graphics->display(void);</div>
<div class="content">
<div class="paragraph">
<p>Manually flushes the current frame buffer out to the display. This function is automatically called after each pass through the run loop, so there shouldn’t be any need to call it yourself.</p>
</div>
</div>
</div>
<div id="f-graphics.getDebugBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->getDebugBitmap(void);</div>
<div class="content">
<div class="paragraph">
<p>Only valid in the simulator, returns the debug framebuffer as a bitmap. Function is NULL on device.</p>
</div>
</div>
</div>
<div id="f-graphics.getDisplayFrame" class="openblock item function">
<div class="title">uint8_t* playdate->graphics->getDisplayFrame(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns the raw bits in the display buffer, the last completed frame.</p>
</div>
</div>
</div>
<div id="f-graphics.getDisplayFrameBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->getDisplayFrameBitmap(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns a bitmap containing the contents of the display buffer. The system owns this bitmap&#8212;&#8203;do not free it!</p>
</div>
</div>
</div>
<div id="f-graphics.getFrame" class="openblock item function">
<div class="title">uint8_t* playdate->graphics->getFrame(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns the current display frame buffer. Rows are 32-bit aligned, so the row stride is 52 bytes, with the extra 2 bytes per row ignored. Bytes are MSB-ordered; i.e., the pixel in column 0 is the 0x80 bit of the first byte of the row.</p>
</div>
</div>
</div>
<div id="f-graphics.copyFrameBufferBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->graphics->copyFrameBufferBitmap(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns a copy the contents of the working frame buffer as a bitmap. The caller is responsible for freeing the returned bitmap with <a href="#f-graphics.freeBitmap">playdate->graphics->freeBitmap()</a>.</p>
</div>
</div>
</div>
<div id="f-system.getLanguage" class="openblock item function">
<div class="title">PDLanguage playdate->system->getLanguage(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns the current language of the system.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">PDLanguage</div>
<div class="content">
<pre>typedef enum
{
	kPDLanguageEnglish,
	kPDLanguageJapanese,
	kPDLanguageUnknown,
} PDLanguage;</pre>
</div>
</div>
<div id="f-graphics.markUpdatedRows" class="openblock item function">
<div class="title">void playdate->graphics->markUpdatedRows(int start, int end);</div>
<div class="content">
<div class="paragraph">
<p>After updating pixels in the buffer returned by getFrame(), you must tell the graphics system which rows were updated. This function marks a contiguous range of rows as updated (e.g., markUpdatedRows(0,LCD_ROWS-1) tells the system to update the entire display). Both “start” and “end” are included in the range.</p>
</div>
</div>
</div>
<div id="f-graphics.setDrawOffset" class="openblock item function xref">
<div class="title">void playdate->graphics->setDrawOffset(int dx, int dy);</div>
<div class="content">
<div class="paragraph">
<p>Offsets the origin point for all drawing calls to <em>x</em>, <em>y</em> (can be negative).</p>
</div>
<div class="paragraph">
<p>This is useful, for example, for centering a "camera" on a sprite that is moving around a world larger than the screen.</p>
</div>
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-graphics.setDrawOffset"><code>playdate.graphics.setDrawOffset()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-graphics.setSpriteDrawFunction" class="openblock item function">
<div class="title">void playdate->graphics->setSpriteDrawFunction(lua_State* L, int pos, LCDSpriteDrawFunction* func);</div>
<div class="content">
<div class="paragraph">
<p>Installs a native drawing function for the given sprite.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">LCDSpriteDrawFunction</div>
<div class="content">
<pre>typedef void LCDSpriteDrawFunction(LCDSprite* sprite, PDRect bounds, PDRect drawrect);</pre>
</div>
</div>
<div class="paragraph">
<p><em>bounds</em> is the current bounds of the sprite, <em>drawrect</em> is the area to draw.</p>
</div>
<div id="f-graphics.setColorToPattern" class="openblock item function">
<div class="title">void playdate->graphics->setColorToPattern(LCDColor* color,LCDBitmap* bitmap, int x, int y);</div>
<div class="content">
<div class="paragraph">
<p>Sets <em>color</em> to an 8 x 8 pattern using the given <em>bitmap</em>. <em>x</em>, <em>y</em> indicates the top left corner of the 8 x 8 pattern.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_video">5.6. Video</h3>
<div id="f-graphics.video.loadVideo" class="openblock item function">
<div class="title">LCDVideoPlayer playdate->graphics->video->loadVideo(const char* path)</div>
<div class="content">
<div class="paragraph">
<p>Opens the <em>pdv</em> file at <em>path</em> and returns a new video player object for rendering its frames.</p>
</div>
</div>
</div>
<div id="f-graphics.video.freePlayer" class="openblock item function">
<div class="title">void playdate->graphics->video->freePlayer(LCDVideoPlayer* p)</div>
<div class="content">
<div class="paragraph">
<p>Frees the given video player.</p>
</div>
</div>
</div>
<div id="f-graphics.video.setContext" class="openblock item function">
<div class="title">int playdate->graphics->video->setContext(LCDVideoPlayer* p, LCDBitmap* context)</div>
<div class="content">
<div class="paragraph">
<p>Sets the rendering destination for the video player to the given bitmap. If the function fails, it returns 0 and sets an error message that can be read via <a href="#f-graphics.video.getError">getError()</a>.</p>
</div>
</div>
</div>
<div id="f-graphics.video.getContext" class="openblock item function">
<div class="title">LCBitmap * playdate->graphics->video->getContext(LCDVideoPlayer* p)</div>
<div class="content">
<div class="paragraph">
<p>Gets the rendering destination for the video player. If no rendering context has been setallocates a context bitmap with the same dimensions as the vieo will be allocated.</p>
</div>
</div>
</div>
<div id="f-graphics.video.useScreenContext" class="openblock item function">
<div class="title">void playdate->graphics->video->useScreenContext(LCDVideoPlayer* p)</div>
<div class="content">
<div class="paragraph">
<p>Sets the rendering destination for the video player to the screen.</p>
</div>
</div>
</div>
<div id="f-graphics.video.renderFrame" class="openblock item function">
<div class="title">void playdate->graphics->video->renderFrame(LCDVideoPlayer* p, int n)</div>
<div class="content">
<div class="paragraph">
<p>Renders frame number <em>n</em> into the current context. In case of error, the function returns 0 and sets an error message that can be read via <a href="#f-graphics.video.getError">getError()</a>.</p>
</div>
</div>
</div>
<div id="f-graphics.video.getError" class="openblock item function">
<div class="title">const char* playdate->graphics->video->getError(LCDVideoPlayer* p)</div>
<div class="content">
<div class="paragraph">
<p>Returns text describing the most recent error.</p>
</div>
</div>
</div>
<div id="f-graphics.video.getInfo" class="openblock item function">
<div class="title">void playdate->graphics->video->getInfo(LCDVideoPlayer* p, int* outWidth, int* outHeight, float* outFrameRate, int* outFrameCount, int* outCurrentFrame)</div>
<div class="content">
<div class="paragraph">
<p>Retrieves information about the video, by passing in (possibly NULL) value pointers.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_input">5.7. Input</h3>
<div id="f-system.setPeripheralsEnabled" class="openblock item function">
<div class="title">void playdate->system->setPeripheralsEnabled(PDPeripherals mask)</div>
<div class="content">
<div class="paragraph">
<p>By default, the accelerometer is disabled to save (a small amount of) power. To use a peripheral, it must first be enabled via this function. Accelerometer data is not available until the next update cycle after it&#8217;s enabled.</p>
</div>
<div class="literalblock">
<div class="title">PDPeripherals</div>
<div class="content">
<pre>kNone
kAccelerometer</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_accelerometer">Accelerometer</h4>
<div id="f-system.getAccelerometer" class="openblock item function">
<div class="title">void playdate->system->getAccelerometer(float* outx, float* outy, float* outz)</div>
<div class="content">
<div class="paragraph">
<p>Returns the last-read accelerometer data.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buttons">Buttons</h4>
<div id="f-system.getButtonState" class="openblock item function">
<div class="title">void playdate->system->getButtonState(PDButtons* current, PDButtons* pushed, PDButtons* released)</div>
<div class="content">
<div class="paragraph">
<p>Sets the value pointed to by <em>current</em> to a bitmask indicating which buttons are currently down. <em>pushed</em> and <em>released</em> reflect which buttons were pushed or released over the previous update cycle—at the nominal frame rate of 50 ms, fast button presses can be missed if you just poll the instantaneous state.</p>
</div>
<div id="_PDButton" class="literalblock">
<div class="title">PDButton</div>
<div class="content">
<pre>kButtonLeft
kButtonRight
kButtonUp
kButtonDown
kButtonB
kButtonA</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_crank">Crank</h4>
<div id="f-system.getCrankAngle" class="openblock item function">
<div class="title">float playdate->system->getCrankAngle(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the current position of the crank, in the range 0-360. Zero is pointing up, and the value increases as the crank moves clockwise, as viewed from the right side of the device.</p>
</div>
</div>
</div>
<div id="f-system.getCrankChange" class="openblock item function">
<div class="title">float playdate->system->getCrankChange(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns the angle change of the crank since the last time this function was called. Negative values are anti-clockwise.</p>
</div>
</div>
</div>
<div id="f-system.isCrankDocked" class="openblock item function">
<div class="title">int playdate->system->isCrankDocked(void)</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 or 0 indicating whether or not the crank is folded into the unit.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="M-autoLock">5.8. Device Auto Lock</h3>
<div class="paragraph">
<p>As of 0.10.3, the device will automatically lock if the user doesn&#8217;t press any buttons or use the crank for more than 60 seconds. In order for games that expect longer periods without interaction to continue to function, it is possible to manually disable the auto lock feature.
Note that when disabling the timeout, developers should take care to re-enable the timeout when appropiate.</p>
</div>
<div id="f-system.setAutoLockDisabled" class="openblock item function">
<div class="title">void playdate->system->setAutoLockDisabled(int disable)</div>
<div class="content">
<div class="paragraph">
<p>Disables or enables the 60 second auto lock feature. When called, the timer is reset to 60 seconds.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="M-systemSounds">5.9. System Sounds</h3>
<div class="paragraph">
<p>0.12 adds sound effects for various system events, such as the menu opening or closing, USB cable plugged or unplugged, and the crank docked or undocked. Since games can receive notification of the crank docking and undocking, and may incorporate this into the game, we&#8217;ve provided a function for muting the default sounds for these events:</p>
</div>
<div id="f-system.setCrankSoundsDisabled" class="openblock item function">
<div class="title">int playdate->system->setCrankSoundsDisabled(int disable)</div>
<div class="content">
<div class="paragraph">
<p>The function returns the previous value for this setting.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_json">5.10. JSON</h3>
<div class="sect3">
<h4 id="_decoding">Decoding</h4>
<div id="f-json.decode" class="openblock item function xref">
<div class="title">int playdate->json->decode(struct json_decoder* decoder, json_reader reader, json_value* outval);</div>
<div class="content">
<div class="paragraph xref xref-lua">
<p>Equivalent to <a href="./Inside%20Playdate.html#f-json.decode"><code>playdate.graphics.decode()</code></a> in the Lua API.</p>
</div>
</div>
</div>
<div id="f-json.decodeString" class="openblock item function">
<div class="title">int playdate->json->decodeString(struct json_decoder* decoder, const char* jsonString, json_value* outval);</div>
<div class="content">
<div class="paragraph">
<p>Decodes a JSON file or string with the given <em>decoder</em>. An instance of json_decoder must implement <em>decodeError</em>. The remaining functions are optional although you&#8217;ll probably want to implement at least <em>didDecodeTableValue</em> and <em>didDecodeArrayValue</em>. The <em>outval</em> pointer, if set, contains the value retured from the top-level <em>didDecodeSublist</em> callback.</p>
</div>
</div>
</div>
<div id="_json_decoder" class="openblock">
<div class="content">
<div class="literalblock">
<div class="title">json_decoder</div>
<div class="content">
<pre>typedef struct json_decoder
{
	void (*decodeError)(json_decoder* decoder, const char* error, int linenum);
	void (*willDecodeSublist)(json_decoder* decoder, const char* name, json_value_type type);
	int (*shouldDecodeTableValueForKey)(json_decoder* decoder, const char* key);
	void (*didDecodeTableValue)(json_decoder* decoder, const char* key, json_value value);
	int (*shouldDecodeArrayValueAtIndex)(json_decoder* decoder, int pos);
	void (*didDecodeArrayValue)(json_decoder* decoder, int pos, json_value value);
	void* (*didDecodeSublist)(json_decoder* decoder, const char* name, json_value_type type);
	void* userdata;
	int returnString;
	const char* path;
} json_decoder;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>decodeError</em>: Called when the decoder encounters an error.</p>
</li>
<li>
<p><em>willDecodeSublist</em>: Called before attempting to decode a JSON object or array.</p>
</li>
<li>
<p><em>didDecodeSublist</em>: Called after successfully decoding a JSON object or array. The returned value is passed to the corresponding <em>didDecodeTableValue()</em> or <em>didDecodeArrayValue()</em> callback one level up, or the calling decode() or decodeString() function if the list is the top-level json object</p>
</li>
<li>
<p><em>shouldDecodeTableValueForKey</em>: Called before decoding a <em>key</em>/<em>value</em> pair from an object. Return 1 to proceed with decoding or return 0 to skip this pair.</p>
</li>
<li>
<p><em>shouldDecodeArrayValueAtIndex</em>: Called before decoding the <em>value</em> at <em>pos</em> from an array (note that <em>pos</em> is base 1 not 0). Return 1 to proceed with decoding or return 0 to skip this index.</p>
</li>
<li>
<p><em>didDecodeTableValue</em>: Called after successfully decoding a <em>key</em>/<em>value</em> pair from an object.</p>
</li>
<li>
<p><em>didDecodeArrayValue</em>: Called after successfully decoding the <em>value</em> at <em>pos</em> from an array.</p>
</li>
<li>
<p><em>userdata</em>: A storage slot for the API client</p>
</li>
<li>
<p><em>returnString</em>: If set in <em>willDecodeSublist</em>, the sublist is returned as a string instead of parsed</p>
</li>
<li>
<p><em>path</em>: The current path in the parse tree. The root scope is named <code>_root</code>, but this is not included in the path when parsing the root&#8217;s children</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that the decoder saves and restores the decoder struct at each level of the tree. This lets you add unique handlers for different sections of the json structure:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void myParser_WillDecodeSublist(json_decoder* decoder, const char* name, json_value_type type)
{
	if ( strcmp(name, "widget") == 0 )
	{
		Widget* widget = pd_malloc(sizeof(Widget));
		decoder-&gt;userdata = widget;
		decoder-&gt;didDecodeTableValue = setWidgetValue;
		decoder-&gt;didDecodeSublist = finishWidget;
	}
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void setWidgetValue(json_decoder* decoder, const char* key, json_value value)
{
	Widget* widget = decoder-&gt;userdata;
	if ( strcmp(key, "floops") == 0 )
		widget.floops = json_floatValue(value);
	// ...
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>void* finishWidget(json_decoder* decoder, const char* name, json_value_type type)
{
	widgetCompleted(decoder-&gt;userdata); // send to external function
	return decoder-&gt;userdata; // or return the widget in didDecodeTableValue()'s value.data.tableval field
}</pre>
</div>
</div>
<div class="paragraph">
<p>After <code>finishWidget()</code> is called and the parser exits the scope, the previous decoder functions are restored.</p>
</div>
<div class="literalblock">
<div class="title">json_value_type</div>
<div class="content">
<pre>typedef enum
{
	kJSONNull,
	kJSONTrue,
	kJSONFalse,
	kJSONInteger,
	kJSONFloat,
	kJSONString,
	kJSONArray,
	kJSONTable
} json_value_type;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">json_value</div>
<div class="content">
<pre>typedef struct
{
	char type;
	union
	{
		int intval;
		float floatval;
		char* stringval;
		void* arrayval;
		void* tableval;
	} data;
} json_value;</pre>
</div>
</div>
</div>
</div>
<div id="f-json_intValue" class="openblock item function">
<div class="title">int json_intValue(json_value value);</div>
<div class="content">

</div>
</div>
<div id="f-json_floatValue" class="openblock item function">
<div class="title">float json_floatValue(json_value value);</div>
<div class="content">

</div>
</div>
<div id="f-json_boolValue" class="openblock item function">
<div class="title">int json_boolValue(json_value value);</div>
<div class="content">

</div>
</div>
<div id="f-json_stringValue" class="openblock item function">
<div class="title">char* json_stringValue(json_value value);</div>
<div class="content">
<div class="paragraph">
<p>Note that a whole number encoded to JSON as a float might be decoded as an int. The above convenience functions can be used to convert a <em>json_value</em> to the required type.</p>
</div>
</div>
</div>
<div id="_json_reader" class="openblock">
<div class="content">
<div class="literalblock">
<div class="title">json_reader</div>
<div class="content">
<pre>typedef struct
{
	int (*read)(void* readud, uint8_t* buf, int bufsize); // fill buffer, return bytes written or 0 on end of data
	void* userdata;
} json_reader;</pre>
</div>
</div>
<div class="paragraph">
<p>json_reader&#8217;s <em>read</em> member provides data to the decoder. It should return 0 when it is done reading. Here&#8217;s an example implementation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int readfile(void* readud, uint8_t* buf, int bufsize) {
	return playdate-&gt;file-&gt;read((SDFile*)readud, buf, bufsize);
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>SDFile* file = pd-&gt;file-&gt;open("data.json", kFileRead);
pd-&gt;json-&gt;decode(&amp;decoder, (json_reader){ .read = readfile, .userdata = file }, NULL);</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_encoding">Encoding</h4>
<div id="f-json.initEncoder" class="openblock item function">
<div class="title">void playdate->json->initEncoder(json_encoder* encoder, writeFunc* write, void* userdata, int pretty);</div>
<div class="content">
<div class="paragraph">
<p>Populates the given json_encoder <em>encoder</em> with the functions necessary to encode arbitrary data into a JSON string. <em>userdata</em> is passed as the first argument of the given writeFunc <em>write</em>. When <em>pretty</em> is 1 the string is written with human-readable formatting.</p>
</div>
</div>
</div>
<div id="_json_encoder" class="openblock">
<div class="content">
<div class="literalblock">
<div class="title">json_encoder</div>
<div class="content">
<pre>typedef struct json_encoder
{
	void (*startArray)(struct json_encoder* encoder);
	void (*addArrayMember)(struct json_encoder* encoder);
	void (*endArray)(struct json_encoder* encoder);
	void (*startTable)(struct json_encoder* encoder);
	void (*addTableMember)(struct json_encoder* encoder, const char* name, int len);
	void (*endTable)(struct json_encoder* encoder);
	void (*writeNull)(struct json_encoder* encoder);
	void (*writeFalse)(struct json_encoder* encoder);
	void (*writeTrue)(struct json_encoder* encoder);
	void (*writeInt)(struct json_encoder* encoder, int num);
	void (*writeDouble)(struct json_encoder* encoder, double num);
	void (*writeString)(struct json_encoder* encoder, const char* str, int len);
} json_encoder;</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the encoder doesn&#8217;t perform any validation. It is up to the caller to ensure they are generating valid JSON.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>startArray</em>: Opens a new JavaScript Array.</p>
</li>
<li>
<p><em>addArrayMember</em>: Creates a new index in the current JavaScript Array.</p>
</li>
<li>
<p><em>endArray</em>: Closes the current JavaScript Array.</p>
</li>
<li>
<p><em>startTable</em>: Opens a new JavaScript Object.</p>
</li>
<li>
<p><em>addTableMember</em>: Creates a new property in the current JavaScript Object.</p>
</li>
<li>
<p><em>endTable</em>: Closes the current JavaScript Object.</p>
</li>
<li>
<p><em>writeNull</em>: Writes the JavaScript primitive null.</p>
</li>
<li>
<p><em>writeFalse</em>: Writes the JavaScript boolean value false.</p>
</li>
<li>
<p><em>writeTrue</em>: Writes the JavaScript boolean value true.</p>
</li>
<li>
<p><em>writeInt</em>: Writes <em>num</em> as a JavaScript number.</p>
</li>
<li>
<p><em>writeDouble</em>: Writes <em>num</em> as a JavaScript number.</p>
</li>
<li>
<p><em>writeString</em>: Writes <em>str</em> of length <em>len</em> as a JavaScript string literal.</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="title">writeFunc</div>
<div class="content">
<pre>typedef void (writeFunc)(void* userdata, const char* str, int len);</pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an example <em>writeFunc</em> implementation using <a href="#f-file.write">playdate->file->write()</a> to write the JSON string to a file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>void writefile(void* userdata, const char* str, int len) {
	playdate-&gt;file-&gt;write((SDFile*)userdata, str, len);
}</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lua">5.11. Lua</h3>
<div class="sect3">
<h4 id="_adding_functions_or_tables">Adding functions or tables</h4>
<div id="f-lua.addFunction" class="openblock item function">
<div class="title">int playdate->lua->addFunction(lua_CFunction f, const char* name, const char** outErr);</div>
<div class="content">
<div class="paragraph">
<p>Adds the Lua function <em>f</em> to the Lua runtime, with name <em>name</em>. (<em>name</em> can be a table path using dots, e.g. if name = “mycode.myDrawingFunction” adds the function “myDrawingFunction” to the global table “myCode”.) Returns 1 on success or 0 with an error message in <em>outErr</em>.</p>
</div>
</div>
</div>
<div id="f-lua.cFunction" class="literalblock">
<div class="title">lua_CFunction</div>
<div class="content">
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>
</div>
</div>
<div class="paragraph">
<p>A <em>lua_CFunction</em> should return the number of return values it has pushed onto the stack. Returns 1 on success or 0 with an error message in <em>outErr</em>. See <a href="#_returning_values_to_lua">Returning values to Lua</a>.</p>
</div>
<div id="f-lua.registerClass_deprecated" class="openblock item function">
<div class="title">void playdate->lua->registerClass_deprecated(const luaL_Reg* reg, const char* name, const char** outErr);</div>
<div class="content">
<div class="paragraph">
<p>Adds the function list <em>reg</em> to the Lua runtime, with the class name <em>name</em>. As above, <em>name</em> can be a table path. The list is terminated with a {NULL, NULL} entry.</p>
</div>
</div>
</div>
<div id="f-lua.registerClass" class="openblock item function">
<div class="title">int playdate->lua->registerClass(const char* name, const lua_reg* reg, const lua_val* vals, int isstatic, const char** outErr);</div>
<div class="content">
<div class="paragraph">
<p>Creates a new "class" (i.e., a Lua metatable containing functions) with the given name and adds the given functions and constants to it. If the table is simply a list of functions that won&#8217;t be used as a metatable, <em>isstatic</em> should be set to 1 to create a plain table instead of a metatable. Please see <code>C_API/Examples/Array</code> for an example of how to use <code>registerClass</code> to create a Lua table-like object from C.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">lua_reg</div>
<div class="content">
<pre>typedef struct lua_reg
{
	const char *name;
	lua_CFunction func;
} lua_reg;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">lua_val</div>
<div class="content">
<pre>typedef struct lua_val
{
	const char *name;
	enum { kInt, kFloat, kStr } type;
	union
	{
		unsigned int intval;
		float floatval;
		const char* strval;
	} v;
} luaL_Val;</pre>
</div>
</div>
<div id="f-lua.indexMetatable" class="openblock item function">
<div class="title">int playdate->lua->indexMetatable(void);</div>
<div class="content">
<div class="paragraph">
<p>If a class includes an <code>__index</code> function, it should call this first to check if the indexed variable exists in the metatable. If the indexMetatable() call returns 1, it has located the variable and put it on the stack, and the <code>__index</code> function should return 1 to indicate a value was found. If indexMetatable() doesn&#8217;t find a value, the <code>__index</code> function can then do its custom getter magic.</p>
</div>
</div>
</div>
<div id="f-lua.start" class="openblock item function">
<div class="title">void playdate->lua->start(void);</div>
<div class="content">
<div class="paragraph">
<p>Starts the run loop back up.</p>
</div>
</div>
</div>
<div id="f-lua.stop" class="openblock item function">
<div class="title">void playdate->lua->stop(void);</div>
<div class="content">
<div class="paragraph">
<p>Stops the run loop.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getting_values_from_lua">Getting values from Lua</h4>
<div class="paragraph">
<p>The following functions are called from within a Lua function implementation to retrieve the function arguments and set the return value(s):</p>
</div>
<div id="f-lua.getArgType" class="openblock item function">
<div class="title">enum LuaType playdate->lua->getArgType(int pos, const char** outClass);</div>
<div class="content">
<div class="paragraph">
<p>Returns the type of the variable at stack position <em>pos</em>. If the type is <em>kTypeObject</em> and <em>outClass</em> is non-NULL, it returns the name of the object&#8217;s metatable.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">LuaType</div>
<div class="content">
<pre>enum LuaType
{
	kTypeNil,
	kTypeBool,
	kTypeInt,
	kTypeFloat,
	kTypeString,
	kTypeTable,
	kTypeFunction,
	kTypeThread,
	kTypeObject
};</pre>
</div>
</div>
<div id="f-lua.getArgCount" class="openblock item function">
<div class="title">int playdate->lua->getArgCount(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns the number of arguments passed to the function.</p>
</div>
</div>
</div>
<div id="f-lua.argIsNil" class="openblock item function">
<div class="title">int playdate->lua->argIsNil(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns 1 if the argument at the given position <em>pos</em> is nil.</p>
</div>
</div>
</div>
<div id="f-lua.getArgBool" class="openblock item function">
<div class="title">int playdate->lua->getArgBool(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns one if the argument at position <em>pos</em> is true, zero if not.</p>
</div>
</div>
</div>
<div id="f-lua.getArgFloat" class="openblock item function">
<div class="title">float playdate->lua->getArgFloat(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as a float.</p>
</div>
</div>
</div>
<div id="f-lua.getArgInt" class="openblock item function">
<div class="title">int playdate->lua->getArgInt(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as an int.</p>
</div>
</div>
</div>
<div id="f-lua.getArgString" class="openblock item function">
<div class="title">const char* playdate->lua->getArgString(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as a string.</p>
</div>
</div>
</div>
<div id="f-lua.getSprite" class="openblock item function">
<div class="title">LCDSprite* playdate->lua->getSprite(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as an LCDSprite.</p>
</div>
</div>
</div>
<div id="f-lua.getArgBytes" class="openblock item function">
<div class="title">const char* playdate->lua->getArgBytes(int pos, size_t* outlen);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as a string and sets <em>outlen</em> to its length.</p>
</div>
</div>
</div>
<div id="f-lua.getBitmap" class="openblock item function">
<div class="title">LCDBitmap* playdate->lua->getBitmap(int pos);</div>
<div class="content">
<div class="paragraph">
<p>Returns the argument at position <em>pos</em> as an LCDBitmap.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_returning_values_to_lua">Returning values to Lua</h4>
<div class="paragraph">
<p>If a function needs to return data to the caller it must return the number of return values pushed onto the stack.</p>
</div>
<div id="f-lua.pushBool" class="openblock item function">
<div class="title">void playdate->lua->pushBool(int val);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the int <em>val</em> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushFloat" class="openblock item function">
<div class="title">void playdate->lua->pushFloat(float val);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the float <em>val</em> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushInt" class="openblock item function">
<div class="title">void playdate->lua->pushInt(int val);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the int <em>val</em> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushNil" class="openblock item function">
<div class="title">void playdate->lua->pushNil(void);</div>
<div class="content">
<div class="paragraph">
<p>Pushes nil onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushString" class="openblock item function">
<div class="title">void playdate->lua->pushString(char* str);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the string <em>str</em> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushBytes" class="openblock item function">
<div class="title">void playdate->lua->pushBytes(char* str, size_t len);</div>
<div class="content">
<div class="paragraph">
<p>Like <em>pushString()</em>, but pushes an arbitrary byte array to the stack, ignoring \0 characters.</p>
</div>
</div>
</div>
<div id="f-lua.pushFunction" class="openblock item function">
<div class="title">void playdate->lua->pushFunction(lua_CFunction f);</div>
<div class="content">
<div class="paragraph">
<p>Pushes a <a href="#f-lua.cFunction">lua_CFunction</a> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushBitmap" class="openblock item function">
<div class="title">void playdate->lua->pushBitmap(LCDBitmap* bitmap);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the LCDBitmap <em>bitmap</em> onto the stack.</p>
</div>
</div>
</div>
<div id="f-lua.pushSprite" class="openblock item function">
<div class="title">void playdate->lua->pushSprite(LCDSprite* sprite);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the LCDSprite <em>sprite</em> onto the stack.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_passing_custom_objects_between_c_and_lua">Passing custom objects between C and Lua</h4>
<div id="f-lua.pushObject" class="openblock item function">
<div class="title">LuaUDObject* playdate->lua->pushObject(void* obj, char* type, int nValues);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the given custom object <em>obj</em> onto the stack and returns a pointer to the opaque LuaUDObject. <em>type</em> must match the class name used in <a href="#f-lua.registerClass">playdate->lua->registerClass()</a>. <em>nValues</em> is the number slots to allocate for Lua values.</p>
</div>
</div>
</div>
<div id="f-lua.getArgObject" class="openblock item function">
<div class="title">void* playdate->lua->getArgObject(int pos, char* type, LuaUDObject** outud);</div>
<div class="content">
<div class="paragraph">
<p>Checks the object type of the argument at position <em>pos</em> and returns a pointer to it if it’s the correct type. Optionally sets <em>outud</em> to a pointer to the opaque LuaUDObject for the given stack.</p>
</div>
</div>
</div>
<div id="f-lua.retainObject" class="openblock item function">
<div class="title">LuaUDObject* playdate->lua->retainObject(LuaUDObject* obj);</div>
<div class="content">
<div class="paragraph">
<p>Retains the opaque LuaUDObject <em>obj</em> and returns same.</p>
</div>
</div>
</div>
<div id="f-lua.releaseObject" class="openblock item function">
<div class="title">void playdate->lua->releaseObject(LuaUDObject* obj);</div>
<div class="content">
<div class="paragraph">
<p>Releases the opaque LuaUDObject <em>obj</em>.</p>
</div>
</div>
</div>
<div id="f-lua.setObjectValue" class="openblock item function">
<div class="title">void playdate->lua->setObjectValue(LuaUDObject* obj, int slot);</div>
<div class="content">
<div class="paragraph">
<p>Sets the value of object <em>obj</em>'s slot number <em>slot</em> to the value at the top of the stack.</p>
</div>
</div>
</div>
<div id="f-lua.getObjectValue" class="openblock item function">
<div class="title">int playdate->lua->getObjectValue(LuaUDObject* obj, int slot);</div>
<div class="content">
<div class="paragraph">
<p>Pushes the value at <em>obj</em>'s given <em>slot</em> to the top of the stack and returns its stack position.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_calling_lua_from_c">Calling Lua from C</h4>
<div id="f-lua.callFunction" class="openblock item function">
<div class="title">int playdate->lua->callFunction(const char* name, int nargs, const char** outerr);</div>
<div class="content">
<div class="paragraph">
<p>Calls the Lua function <em>name</em> and and indicates that <em>nargs</em> number of arguments have already been pushed to the stack for the function to use. <em>name</em> can be a table path using dots, e.g. “playdate.apiVersion”. Returns 1 on success; on failure, returns 0 and puts an error message into the <code>outerr</code> pointer, if it&#8217;s set. Calling Lua from C is slow, so use sparingly.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sprites">5.12. Sprites</h3>
<div id="f-sprite.newSprite" class="openblock item function">
<div class="title">LCDSprite* playdate->sprite->newSprite(void);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a new LCDSprite.</p>
</div>
</div>
</div>
<div id="f-sprite.copy" class="openblock item function">
<div class="title">LCDSprite* playdate->sprite->copy(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Allocates and returns a copy of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.free" class="openblock item function">
<div class="title">void playdate->sprite->free(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Frees the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_properties">Properties</h4>
<div id="f-sprite.setBounds" class="openblock item function">
<div class="title">void playdate->sprite->setBounds(LCDSprite *sprite, PDRect bounds);</div>
<div class="content">
<div class="paragraph">
<p>Sets the bounds of the given <em>sprite</em> with <em>bounds</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.getBounds" class="openblock item function">
<div class="title">PDRect playdate->sprite->getBounds(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the bounds of the given <em>sprite</em> as an PDRect;</p>
</div>
</div>
</div>
<div id="f-sprite.moveTo" class="openblock item function">
<div class="title">void playdate->sprite->moveTo(LCDSprite *sprite, float x, float y);</div>
<div class="content">
<div class="paragraph">
<p>Moves the given <em>sprite</em> to <em>x</em>, <em>y</em> and resets its bounds based on the bitmap dimensions and center.</p>
</div>
</div>
</div>
<div id="f-sprite.moveBy" class="openblock item function">
<div class="title">void playdate->sprite->moveBy(LCDSprite *sprite, float dx, float dy);</div>
<div class="content">
<div class="paragraph">
<p>Moves the given <em>sprite</em> to by offsetting its current position by <em>dx</em>, <em>dy</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.getPosition" class="openblock item function">
<div class="title">void playdate->sprite->getPosition(LCDSprite *sprite, int *x, int *y);</div>
<div class="content">
<div class="paragraph">
<p>Sets <em>x</em> and <em>y</em> to the current position of <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setImage" class="openblock item function">
<div class="title">void playdate->sprite->setImage(LCDSprite *sprite, LCDBitmap *image, LCDBitmapFlip flip);</div>
<div class="content">
<div class="paragraph">
<p>Sets the given <em>sprite</em>'s image to the given <em>bitmap</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.getImage" class="openblock item function">
<div class="title">LCDBitmap* playdate->sprite->getImage(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the LCDBitmap currently assigned to the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setSize" class="openblock item function">
<div class="title">void playdate->sprite->setSize(LCDSprite *s, float width, float height);</div>
<div class="content">
<div class="paragraph">
<p>Sets the size. The size is used to set the sprite’s bounds when calling moveTo().</p>
</div>
</div>
</div>
<div id="f-sprite.setZIndex" class="openblock item function">
<div class="title">void playdate->sprite->setZIndex(LCDSprite *sprite, int16_t zIndex);</div>
<div class="content">
<div class="paragraph">
<p>Sets the Z order of the given <em>sprite</em>. Higher Z sprites are drawn on top of those with lower Z order.</p>
</div>
</div>
</div>
<div id="f-sprite.getZIndex" class="openblock item function">
<div class="title">int16_t playdate->sprite->getZIndex(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the Z index of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setTag" class="openblock item function">
<div class="title">void playdate->sprite->setTag(LCDSprite *sprite, uint8_t tag);</div>
<div class="content">
<div class="paragraph">
<p>Sets the tag of the given <em>sprite</em>. This can be useful for identifying sprites or types of sprites when using the collision API.</p>
</div>
</div>
</div>
<div id="f-sprite.getTag" class="openblock item function">
<div class="title">uint8_t playdate->sprite->getTag(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the tag of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setDrawMode" class="openblock item function">
<div class="title">void playdate->sprite->setDrawMode(LCDSprite *sprite, LCDBitmapDrawMode mode);</div>
<div class="content">
<div class="paragraph">
<p>Sets the mode for drawing the sprite&#8217;s bitmap.</p>
</div>
</div>
</div>
<div id="f-sprite.setImageFlip" class="openblock item function">
<div class="title">void playdate->sprite->setImageFlip(LCDSprite *sprite, LCDBitmapFlip flip);</div>
<div class="content">
<div class="paragraph">
<p>Flips the bitmap.</p>
</div>
</div>
</div>
<div id="f-sprite.getImageFlip" class="openblock item function">
<div class="title">LCDBitmapFlip playdate->sprite->getImageFlip(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the flip setting of the sprite&#8217;s bitmap.</p>
</div>
</div>
</div>
<div id="f-sprite.setStencil" class="openblock item function">
<div class="title">void playdate->sprite->setStencil(LCDSprite *sprite, LCDBitmap* stencil);</div>
<div class="content">
<div class="paragraph">
<p>Specifies a stencil image to be set on the frame buffer before the sprite is drawn.</p>
</div>
</div>
</div>
<div id="f-sprite.setStencilImage" class="openblock item function">
<div class="title">void playdate->sprite->setStencilImage(LCDSprite *sprite, LCDBitmap* stencil, int tile);</div>
<div class="content">
<div class="paragraph">
<p>Specifies a stencil image to be set on the frame buffer before the sprite is drawn. If <em>tile</em> is set, the stencil will be tiled. Tiled stencils must have width evenly divisible by 32.</p>
</div>
</div>
</div>
<div id="f-sprite.setStencilPattern" class="openblock item function">
<div class="title">void playdate->sprite->setStencilPattern(LCDSprite* sprite, uint8_t pattern[8]);</div>
<div class="content">
<div class="paragraph">
<p>Sets the sprite&#8217;s stencil to the given pattern.</p>
</div>
</div>
</div>
<div id="f-sprite.clearStencil" class="openblock item function">
<div class="title">void playdate->sprite->clearStencil(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Clears the sprite&#8217;s stencil.</p>
</div>
</div>
</div>
<div id="f-sprite.setClipRect" class="openblock item function">
<div class="title">void playdate->sprite->setClipRect(LCDSprite *sprite, LCDRect clipRect);</div>
<div class="content">
<div class="paragraph">
<p>Sets the clipping rectangle for sprite drawing.</p>
</div>
</div>
</div>
<div id="f-sprite.clearClipRect" class="openblock item function">
<div class="title">void playdate->sprite->clearClipRect(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Clears the sprite&#8217;s clipping rectangle.</p>
</div>
</div>
</div>
<div id="f-sprite.setClipRectsInRange" class="openblock item function">
<div class="title">void playdate->sprite->setClipRectsInRange(LCDRect clipRect, int startZ, int endZ);</div>
<div class="content">
<div class="paragraph">
<p>Sets the clipping rectangle for <em>all</em> sprites with a Z index within <em>startZ</em> and <em>endZ</em> inclusive.</p>
</div>
</div>
</div>
<div id="f-sprite.clearClipRectsInRange" class="openblock item function">
<div class="title">void playdate->sprite->clearClipRectsInRange(int startZ, int endZ);</div>
<div class="content">
<div class="paragraph">
<p>Clears the clipping rectangle for <em>all</em> sprites with a Z index within <em>startZ</em> and <em>endZ</em> inclusive.</p>
</div>
</div>
</div>
<div id="f-sprite.setUpdatesEnabled" class="openblock item function">
<div class="title">void playdate->sprite->setUpdatesEnabled(LCDSprite *sprite, int flag);</div>
<div class="content">
<div class="paragraph">
<p>Set the updatesEnabled flag of the given <em>sprite</em> (determines whether the sprite has its update function called). One is true, 0 is false.</p>
</div>
</div>
</div>
<div id="f-sprite.updatesEnabled" class="openblock item function">
<div class="title">int playdate->sprite->updatesEnabled(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Get the updatesEnabled flag of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setVisible" class="openblock item function">
<div class="title">void playdate->sprite->setVisible(LCDSprite *sprite, int flag);</div>
<div class="content">
<div class="paragraph">
<p>Set the visible flag of the given <em>sprite</em> (determines whether the sprite has its draw function called). One is true, 0 is false.</p>
</div>
</div>
</div>
<div id="f-sprite.isVisible" class="openblock item function">
<div class="title">int playdate->sprite->isVisible(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Get the visible flag of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setOpaque" class="openblock item function">
<div class="title">void playdate->sprite->setOpaque(LCDSprite *sprite, int flag);</div>
<div class="content">
<div class="paragraph">
<p>Marking a sprite opaque tells the sprite system that it doesn’t need to draw anything underneath the sprite, since it will be overdrawn anyway. If you set an image without a mask/alpha channel on the sprite, it automatically sets the opaque flag.</p>
</div>
</div>
</div>
<div id="f-sprite.setAlwaysRedraw" class="openblock item function">
<div class="title">void playdate->sprite->setAlwaysRedraw(int flag);</div>
<div class="content">
<div class="paragraph">
<p>When <em>flag</em> is set to 1, the given <em>sprite</em> will always redraw.</p>
</div>
</div>
</div>
<div id="f-sprite.markDirty" class="openblock item function">
<div class="title">void playdate->sprite->markDirty(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Forces the given <em>sprite</em> to redraw.</p>
</div>
</div>
</div>
<div id="f-sprite.addDirtyRect" class="openblock item function">
<div class="title">void playdate->sprite->addDirtyRect(LCDRect dirtyRect);</div>
<div class="content">
<div class="paragraph">
<p>Marks the given <em>dirtyRect</em> (in screen coordinates) as needing a redraw. Graphics drawing functions now call this automatically, adding their drawn areas to the sprite&#8217;s dirty list, so there&#8217;s usually no need to call this manually.</p>
</div>
</div>
</div>
<div id="f-sprite.setIgnoresDrawOffset" class="openblock item function">
<div class="title">void playdate->sprite->setIgnoresDrawOffset(LCDSprite *sprite, int flag);</div>
<div class="content">
<div class="paragraph">
<p>When <em>flag</em> is set to 1, the <em>sprite</em> will draw in screen coordinates, ignoring the currently-set drawOffset.</p>
</div>
<div class="paragraph">
<p>This only affects drawing, and should not be used on sprites being used for collisions, which will still happen in world-space.</p>
</div>
</div>
</div>
<div id="f-sprite.setUpdateFunction" class="openblock item function">
<div class="title">void playdate->sprite->setUpdateFunction(LCDSprite *sprite, LCDSpriteUpdateFunction *func);</div>
<div class="content">
<div class="paragraph">
<p>Sets the update function for the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">LCDSpriteUpdateFunction</div>
<div class="content">
<pre>typedef void LCDSpriteUpdateFunction(LCDSprite* sprite);</pre>
</div>
</div>
<div id="f-sprite.setDrawFunction" class="openblock item function">
<div class="title">void playdate->sprite->setDrawFunction(LCDSprite *sprite, LCDSpriteDrawFunction *func);</div>
<div class="content">
<div class="paragraph">
<p>Sets the draw function for the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">LCDSpriteDrawFunction</div>
<div class="content">
<pre>typedef void LCDSpriteDrawFunction(LCDSprite* sprite, LCDRect bounds, uint8_t* frame, LCDRect drawrect);</pre>
</div>
</div>
<div class="paragraph">
<p>If the sprite doesn’t have an image, the sprite’s draw function is called as needed to update the display. <em>bounds</em> is the bounds of hte given <em>sprite</em>. <em>frame</em> is the raw bitmap data of the current frame buffer. <em>drawRect</em> is the current dirty rect being updated by the display list.</p>
</div>
<div id="f-sprite.setUserdata" class="openblock item function">
<div class="title">void playdate->sprite->setUserdata(LCDSprite *sprite, void* userdata);</div>
<div class="content">

</div>
</div>
<div id="f-sprite.getUserdata" class="openblock item function">
<div class="title">void* playdate->sprite->getUserdata(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Sets and gets the sprite&#8217;s userdata, an arbitrary pointer used for associating the sprite with other data.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_display_list">Display List</h4>
<div id="f-sprite.addSprite" class="openblock item function">
<div class="title">void playdate->sprite->addSprite(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Adds the given <em>sprite</em> to the display list, so that it is drawn in the current scene.</p>
</div>
</div>
</div>
<div id="f-sprite.removeSprite" class="openblock item function">
<div class="title">void playdate->sprite->removeSprite(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Removes the given <em>sprite</em> from the display list.</p>
</div>
</div>
</div>
<div id="f-sprite.removeSprites" class="openblock item function">
<div class="title">void playdate->sprite->removeSprites(LCDSprite **sprites, int count);</div>
<div class="content">
<div class="paragraph">
<p>Removes the given <em>count</em> sized array of <em>sprites</em> from the display list.</p>
</div>
</div>
</div>
<div id="f-sprite.removeAllSprites" class="openblock item function">
<div class="title">void playdate->sprite->removeAllSprites(void);</div>
<div class="content">
<div class="paragraph">
<p>Removes all sprites from the display list.</p>
</div>
</div>
</div>
<div id="f-sprite.getSpriteCount" class="openblock item function">
<div class="title">int playdate->sprite->getSpriteCount(void);</div>
<div class="content">
<div class="paragraph">
<p>Returns the total number of sprites in the display list.</p>
</div>
</div>
</div>
<div id="f-sprite.drawSprites" class="openblock item function">
<div class="title">void playdate->sprite->drawSprites(void);</div>
<div class="content">
<div class="paragraph">
<p>Draws every sprite in the display list.</p>
</div>
</div>
</div>
<div id="f-sprite.updateAndDrawSprites" class="openblock item function">
<div class="title">void playdate->sprite->updateAndDrawSprites(void);</div>
<div class="content">
<div class="paragraph">
<p>Updates and draws every sprite in the display list.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_collisions">Collisions</h4>
<div class="paragraph">
<p>Note that the caller is responsible for freeing any arrays returned by these collision methods.</p>
</div>
<div id="f-sprite.resetCollisionWorld" class="openblock item function">
<div class="title">void playdate->sprite->resetCollisionWorld(void);</div>
<div class="content">
<div class="paragraph">
<p>Frees and reallocates internal collision data, resetting everything to its default state.</p>
</div>
</div>
</div>
<div id="f-sprite.setCollisionsEnabled" class="openblock item function">
<div class="title">void playdate->sprite->setCollisionsEnabled(LCDSprite *sprite, int flag);</div>
<div class="content">
<div class="paragraph">
<p>Set the collisionsEnabled flag of the given <em>sprite</em> (along with the collideRect, this determines whether the sprite participates in collisions). One is true, 0 is false. Set to 1 by default.</p>
</div>
</div>
</div>
<div id="f-sprite.collisionsEnabled" class="openblock item function">
<div class="title">int playdate->sprite->collisionsEnabled(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Get the collisionsEnabled flag of the given <em>sprite</em>.</p>
</div>
</div>
</div>
<div id="f-sprite.setCollideRect" class="openblock item function">
<div class="title">void playdate->sprite->setCollideRect(LCDSprite *sprite, PDRect collideRect);</div>
<div class="content">
<div class="paragraph">
<p>Marks the area of the given <em>sprite</em>, relative to its bounds, to be checked for collisions with other sprites' collide rects.</p>
</div>
</div>
</div>
<div id="f-sprite.getCollideRect" class="openblock item function">
<div class="title">PDRect playdate->sprite->getCollideRect(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Returns the given <em>sprite</em>’s collide rect.</p>
</div>
</div>
</div>
<div id="f-sprite.clearCollideRect" class="openblock item function">
<div class="title">void playdate->sprite->clearCollideRect(LCDSprite *sprite);</div>
<div class="content">
<div class="paragraph">
<p>Clears the given <em>sprite</em>’s collide rect.</p>
</div>
</div>
</div>
<div id="f-sprite.setCollisionResponseFunction" class="openblock item function">
<div class="title">void playdate->sprite->setCollisionResponseFunction(LCDSprite *sprite, LCDSpriteCollisionFilterProc *func);</div>
<div class="content">
<div class="paragraph">
<p>Set a callback that returns a <a href="#_SpriteCollisionResponseType">SpriteCollisionResponseType</a> for a collision between <em>sprite</em> and <em>other</em>.</p>
</div>
<div class="literalblock">
<div class="title">LCDSpriteCollisionFilterProc</div>
<div class="content">
<pre>typedef SpriteCollisionResponseType LCDSpriteCollisionFilterProc(LCDSprite* sprite, LCDSprite* other);</pre>
</div>
</div>
</div>
</div>
<div id="f-sprite.checkCollisions" class="openblock item function">
<div class="title">SpriteCollisionInfo* playdate->sprite->checkCollisions(LCDSprite *sprite, float goalX, float goalY, float *actualX, float *actualY, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns the same values as <a href="#f-sprite.moveWithCollisions">playdate->sprite->moveWithCollisions()</a> but does not actually move the sprite.</p>
</div>
</div>
</div>
<div id="f-sprite.moveWithCollisions" class="openblock item function">
<div class="title">SpriteCollisionInfo* playdate->sprite->moveWithCollisions(LCDSprite *sprite, float goalX, float goalY, float *actualX, float *actualY, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Moves the given <em>sprite</em> towards <em>goalX</em>, <em>goalY</em> taking collisions into account and returns an array of SpriteCollisionInfo. <em>len</em> is set to the size of the array and <em>actualX</em>, <em>actualY</em> are set to the sprite&#8217;s position after collisions. If no collisions occurred, this will be the same as <em>goalX</em>, <em>goalY</em>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that SpriteCollisionInfo is a struct so you should grab a pointer when accessing each one: <code>SpriteCollisionInfo *info = &amp;results[i];</code>.</p>
</div>
<div class="literalblock">
<div class="title">SpriteCollisionInfo</div>
<div class="content">
<pre>struct SpriteCollisionInfo
{
	LCDSprite *sprite;
	LCDSprite *other;
	SpriteCollisionResponseType responseType;
	uint8_t overlaps;
	float ti;
	CollisionPoint move;
	CollisionVector normal;
	CollisionPoint touch;
	PDRect spriteRect;
	PDRect otherRect;
};</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>sprite</em>: The sprite being moved.</p>
</li>
<li>
<p><em>other</em>: The sprite colliding with the sprite being moved.</p>
</li>
<li>
<p><em>type</em>: The result of collisionResponse (see <a href="#_SpriteCollisionResponseType">SpriteCollisionResponseType</a> below).</p>
</li>
<li>
<p><em>overlaps</em>: One if the sprite was overlapping other when the collision started. Zero if it didn’t overlap but tunneled through other.</p>
</li>
<li>
<p><em>ti</em>: A number between 0 and 1 indicating how far along the movement to the goal the collision occurred.</p>
</li>
<li>
<p><em>move</em>: The difference between the original coordinates and the actual ones when the collision happened (see <a href="#_CollisionPoint">CollisionPoint</a> below).</p>
</li>
<li>
<p><em>normal</em>: The collision normal; usually -1, 0, or 1 in x and y. Use this value to determine things like if your character is touching the ground (see <a href="#_CollisionVector">CollisionVector</a> below).</p>
</li>
<li>
<p><em>touch</em>: The coordinates where the sprite started touching other.</p>
</li>
<li>
<p><em>spriteRect</em>: The rectangle the sprite occupied when the touch happened.</p>
</li>
<li>
<p><em>otherRect</em>: The rectangle other occupied when the touch happened.</p>
</li>
</ul>
</div>
<div id="_SpriteCollisionResponseType" class="literalblock">
<div class="title">SpriteCollisionResponseType</div>
<div class="content">
<pre>typedef enum {
	kSpriteCollisionTypeSlide,
	kSpriteCollisionTypeFreeze,
	kSpriteCollisionTypeOverlap,
	kSpriteCollisionTypeBounce
} SpriteCollisionResponseType;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>kSpriteCollisionTypeSlide</em>: Use for collisions that should slide over other objects, like Super Mario does over a platform or the ground.</p>
</li>
<li>
<p><em>kSpriteCollisionTypeFreeze</em>: Use for collisions where the sprite should stop moving as soon as it collides with other, such as an arrow hitting a wall.</p>
</li>
<li>
<p><em>kSpriteCollisionTypeOverlap</em>: Use for collisions in which you want to know about the collision but it should not impact the movement of the sprite, such as when collecting a coin.</p>
</li>
<li>
<p><em>kSpriteCollisionTypeBounce</em>: Use when the sprite should move away from other, like the ball in Pong or Arkanoid.</p>
</li>
</ul>
</div>
<div id="_CollisionPoint" class="literalblock">
<div class="title">CollisionPoint</div>
<div class="content">
<pre>typedef struct {
	float x;
	float y;
} CollisionPoint;</pre>
</div>
</div>
<div id="_CollisionVector" class="literalblock">
<div class="title">CollisionVector</div>
<div class="content">
<pre>typedef struct {
	int x;
	int y;
} CollisionVector;</pre>
</div>
</div>
<div id="f-sprite.querySpritesAtPoint" class="openblock item function">
<div class="title">LCDSprite** playdate->sprite->querySpritesAtPoint(float x, float y, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of all sprites with collision rects containing the point at <em>x</em>, <em>y</em>. <em>len</em> is set to the size of the array.</p>
</div>
</div>
</div>
<div id="f-sprite.querySpritesInRect" class="openblock item function">
<div class="title">LCDSprite** playdate->sprite->querySpritesInRect(float x, float y, float width, float height, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of all sprites with collision rects that intersect the <em>width</em> by <em>height</em> rect at <em>x</em>, <em>y</em>. <em>len</em> is set to the size of the array.</p>
</div>
</div>
</div>
<div id="f-sprite.querySpritesAlongLine" class="openblock item function">
<div class="title">LCDSprite** playdate->sprite->querySpritesAlongLine(float x1, float y1, float x2, float y2, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of all sprites with collision rects that intersect the line connecting <em>x1</em>, <em>y1</em> and  <em>x2</em>, <em>y2</em>. <em>len</em> is set to the size of the array.</p>
</div>
</div>
</div>
<div id="f-sprite.querySpriteInfoAlongLine" class="openblock item function">
<div class="title">SpriteQueryInfo* playdate->sprite->querySpriteInfoAlongLine(float x1, float y1, float x2, float y2, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of SpriteQueryInfo for all sprites with collision rects that intersect the line connecting <em>x1</em>, <em>y1</em> and  <em>x2</em>, <em>y2</em>. <em>len</em> is set to the size of the array. If you don’t need this information, use querySpritesAlongLine() as it will be faster.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that SpriteQueryInfo is a struct so you should grab a pointer when accessing each one: <code>SpriteQueryInfo *info = &amp;results[i];</code>.</p>
</div>
<div class="literalblock">
<div class="title">SpriteQueryInfo</div>
<div class="content">
<pre>struct SpriteQueryInfo
{
	LCDSprite *sprite;
	float ti1;
	float ti2;
	CollisionPoint entryPoint;
	CollisionPoint exitPoint;
};</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>sprite</em>: The sprite being intersected by the segment.</p>
</li>
<li>
<p><em>ti1</em> &amp; <em>ti2</em>: Numbers between 0 and 1 which indicate how far from the starting point of the line segment the collision happened. <em>ti1</em> is relative to the entry point, <em>ti2</em> is  relative to the exit point.</p>
</li>
<li>
<p><em>entryPoint</em>: The coordinates of the first intersection between sprite and the line segment (see <a href="#_CollisionPoint">CollisionPoint</a> above).</p>
</li>
<li>
<p><em>exitPoint</em>: The coordinates of the second intersection between sprite and the line segment (see <a href="#_CollisionPoint">CollisionPoint</a> above).</p>
</li>
</ul>
</div>
<div id="f-sprite.overlappingSprites" class="openblock item function">
<div class="title">LCDSprite** playdate->sprite->overlappingSprites(LCDSprite *sprite, int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of sprites that have collide rects that are currently overlapping the given <em>sprite</em>’s collide rect. <em>len</em> is set to the size of the array.</p>
</div>
</div>
</div>
<div id="f-sprite.allOverlappingSprites" class="openblock item function">
<div class="title">LCDSprite** playdate->sprite->allOverlappingSprites(int *len);</div>
<div class="content">
<div class="paragraph">
<p>Returns an array of all sprites that have collide rects that are currently overlapping. Each consecutive pair of sprites is overlapping (eg. 0 &amp; 1 overlap, 2 &amp; 3 overlap, etc). <em>len</em> is set to the size of the array.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 section">
<h2 id="performance-considerations">6. Performance Considerations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_floating_point_math_operations">6.1. Floating point Math operations</h3>
<div class="paragraph">
<p>The Cortex-M7 processor used in the Playdate has support for <em>single</em> precision floating point operations (ie. the <code>float</code> type), but <strong>not</strong> for <em>double</em> precision operations (ie. the <code>double</code> type).</p>
</div>
<div class="paragraph">
<p>When using <code>double</code> precision values, the compiler will emit code that emulates double-precision floating point calcuations, rather than using the specialized hardware for single-precision floating point calculations. This is extremely slow in comparison, and will come at a large cost of performance.</p>
</div>
<div class="paragraph">
<p>One small (but important) thing to keep in mind is that constant floating point values, like <code>3.14</code> are implicitly <code>double</code> typed values at compile time. Ensure that any constant values are floats by adding the <code>f</code> suffix: <code>3.14f</code>, <code>1.f</code>, and so on.</p>
</div>
<div class="paragraph">
<p>The C standard library has variants on its math functions with operate on either <code>double</code> or <code>float</code> values. When using these, make sure that you are using the <code>float</code> variant. For example, ensure you are using <code>fabsf()</code> not <code>fabs()</code>, and <code>powf()</code> rather thatn <code>pow()</code>, and so on.</p>
</div>
<div class="paragraph">
<p>Some compiler flags can be used to make these mistakes obvious or easier to deal with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Wdouble-promotion</code>: Warns whenever a <code>float</code> is implicitly being converted to double.</p>
</li>
<li>
<p><code>-fsingle-precision-constant</code>: All real constants will be <code>float</code> rather than <code>double</code>, ie. <code>1.0</code> will be the same as <code>1.0f</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1 section">
<h2 id="getting-help">7. Getting Help</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_where_can_i_download_the_sdk">7.1. Where can I download the SDK?</h3>
<div class="paragraph">
<p>Head to the <a href="https://play.date/dev/">Playdate Developer</a> page to download the latest SDK.</p>
</div>
</div>
<div class="sect2">
<h3 id="_where_do_i_go_if_i_have_questions_about_the_sdk">7.2. Where do I go if I have questions about the SDK?</h3>
<div class="paragraph">
<p>You can find the SDK documentation for Lua <a href="https://sdk.play.date/inside-playdate">here</a> and C <a href="https://sdk.play.date/inside-playdate-with-c">here</a> . If you&#8217;re interested in seeing the Playdate SDK in action, check out our <a href="https://www.twitch.tv/videos/608372277">Twitch stream</a> . For tips on making Playdate games, <a href="https://sdk.play.date/designing-for-playdate">click here</a>.</p>
</div>
<div class="paragraph">
<p>Searching in the <a href="https://devforum.play.date/c/get-help/38">Get Help</a> and <a href="https://devforum.play.date/c/development-discussion/80">Development Discussion</a> on our Developer Forum to find solutions will also be a good place to look at. If you still need help, the best way to get help from either the community or Panic is to post in that same Get Help category.</p>
</div>
</div>
<div class="sect2">
<h3 id="_where_do_i_report_bugs_or_issues_relating_to_the_sdk">7.3. Where do I report bugs or issues relating to the SDK?</h3>
<div class="paragraph">
<p>Head to the <a href="https://devforum.play.date/c/bugs/47">Bug Reports</a> category and check the <a href="https://devforum.play.date/t/about-the-bug-reports-category/1463">Bug Report category info</a> for information on how to post a bug report. One of us at Panic will take a look at it!
And what if I have feature requests?</p>
</div>
<div class="paragraph">
<p>To share your ideas, suggestions, and requests relating to Playdate, head to the <a href="https://devforum.play.date/c/feature-requests/48">Feature Request</a> category and check the <a href="https://devforum.play.date/t/about-the-feature-requests-category/1464">Feature Request category info</a> before posting your feature request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_list_of_helpful_libraries_and_code">7.4. List of Helpful Libraries and Code</h3>
<div class="paragraph">
<p>This thread includes some helpful tips from the community. Check it out <a href="https://devforum.play.date/t/a-list-of-helpful-libraries-and-code/221">here</a>. For more resources, head to the <a href="https://devforum.play.date/c/development-discussion/80">Development Discussion</a> category.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_legal_information">8. Legal information</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Playdate fonts are licensed to you under the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International (CC BY 4.0) license.</a></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-07-12 05:03:16 UTC
</div>
</div>
</body>
</html>